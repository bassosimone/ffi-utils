// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// \file include/measurement_kit/nettest.h
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.

#include <stdint.h>

#include <iostream>
#include <map>
#include <string>
#include <vector>

#include <measurement_kit/ffi.h>
#include <nlohmann/json.hpp>

/// Namespace containing MK code.
namespace mk {

/// Namespace containing the nettest API.
namespace nettest {

/// Contains all the events emitted by nettests.
namespace event {

/// We could not lookup the ASN from the probe IP.
class FailureAsnLookup {
 public:
  /// The specific error that occurred.
  std::string failure = "";
};

/// Status update regarding the currently ongoing network performance
/// measurement. This event is, of course, only emitted by network tests that
/// measure the network performance.
class StatusUpdatePerformance {
 public:
  /// The direction of the performance measurement. Either 'download', for
  /// download measurements, or 'upload' for upload measurements.
  std::string direction = "";

  /// Seconds elapsed since the performance measurement was started.
  double elapsed = 0.0;

  /// Number of parallel TCP streams being used.
  int64_t num_streams = 0;

  /// Speed measured in kbit/s.
  double speed_kbps = 0.0;
};

}  // namespace event

/// Scalar options controlling the behavior of a nettest. If none of
/// these options are specified, the default values are used.
class Options {
 public:
  /// Base URL of the OONI bouncer. This base URL is used to construct the full
  /// URL required to contact the OONI bouncer and get test specific info like
  /// test helpers and test collectors.
  std::string bouncer_base_url = "https://bouncer.ooni.io";

  /// DNS resolver IP address. By setting this option you will force MK to use
  /// that DNS resolver for resolving domain names to IP addresses. Otherwise MK
  /// will use the system resolver (i.e. it will call `getaddrinfo()`).
  std::string dns_nameserver = "";

  /// Whether to ignore bouncer errors. If this option is true, then MK will not
  /// stop after failing to contact the OONI bouncer. Without the information
  /// provided by the bouncer, some tests MAY still work, while others (e.g.
  /// OONI tests) will most likely fail.
  double ignore_bouncer_error = true;

  /// Max run time for nettests taking input. When you are running a nettest
  /// taking input, the test will stop after the number of seconds specified by
  /// this option has passed.
  double max_runtime = -1.0;
};

/// Settings specifying what test to run, with what input, etc.
class Settings {
 public:
  /// Optional annotations (i.e. key, value string pairs) that will be included
  /// into the JSON report sent to the OONI collector.
  std::map<std::string, std::string> annotations = {};

  /// List of events that will not be emitted.
  std::vector<std::string> disabled_events = {};

  /// Name of the test.
  std::string name = "";

  /// Options controlling the behavior of a nettest.
  Options options = {};
};

/// A network test.
class Nettest {
 public:
  /// Called when the FailureAsnLookup event occurs.
  virtual void on_failure_asn_lookup(const event::FailureAsnLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusUpdatePerformance event occurs.
  virtual void on_status_update_performance(
      const event::StatusUpdatePerformance &) {
    // TODO: override this callback if you're interested
  }

  /// Create a nettest using the specified settings.
  explicit Nettest(Settings s) noexcept { std::swap(s, settings_); }

  /// Runs the nettest until completion.
  void run();

  /// Releases allocated resources.
  virtual ~Nettest() noexcept;

 private:
  Settings settings_;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can include by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#ifndef MK_NETTEST_NO_INLINE_IMPL

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

Nettest::~Nettest() noexcept {}

void Nettest::run() {
  UniqueTask task;
  {
    nlohmann::json s;
    s["annotations"] = settings_.annotations;
    s["disabled_events"] = settings_.disabled_events;
    s["name"] = settings_.name;
    s["options"] = settings_.options;
    {
      nlohmann::json so;
      Options &opts = settings_.options;
      so["bouncer_base_url"] = opts.bouncer_base_url;
      so["dns/nameserver"] = opts.dns_nameserver;
      so["ignore_bouncer_error"] = (int64_t)opts.ignore_bouncer_error;
      so["max_runtime"] = opts.max_runtime;
      s["options"] = so;
    }
    task.reset(mk_task_start(s.dump().c_str()));
    if (!task) {
      throw std::runtime_error("mk_task_start() failed");
    }
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
      ev = nlohmann::json::parse(str);
    }
    if (ev.at("key") == "failure.asn_lookup") {
      event::FailureAsnLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_asn_lookup(event);
      continue;
    }
    if (ev.at("key") == "status.update_performance") {
      event::StatusUpdatePerformance event;
      event.direction = ev.at("value").at("direction");
      event.elapsed = ev.at("value").at("elapsed");
      event.num_streams = ev.at("value").at("num_streams");
      event.speed_kbps = ev.at("value").at("speed_kbps");
      on_status_update_performance(event);
      continue;
    }
    std::clog << "unhandled event: " << ev.at("key");
  }
}
#endif  // MK_NETTEST_NO_INLINE_IMPL

}  // namespace nettest
}  // namespace mk
#endif  // MEASUREMENT_KIT_NETTEST_HPP
