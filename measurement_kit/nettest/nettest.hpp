// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// \file include/measurement_kit/nettest/nettest.hpp
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.

#include <stdint.h>

#include <iostream>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include <measurement_kit/ffi.h>
#include <nlohmann/json.hpp>

/// Namespace containing MK code.
namespace mk {

/// Namespace containing the nettest API.
namespace nettest {

/// Contains all the events emitted by nettests.
namespace event {

/// We could not lookup the ASN from the probe IP.
class FailureAsnLookup {
 public:
  /// The key that uniquely identifies an event. You can pass use this key
  /// with Settings to disable this specific event.
  constexpr const char *event_key = "failure.asn_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// Status update regarding the currently ongoing network performance
/// measurement. This event is, of course, only emitted by network tests that
/// measure the network performance.
class StatusUpdatePerformance {
 public:
  /// The key that uniquely identifies an event. You can pass use this key
  /// with Settings to disable this specific event.
  constexpr const char *event_key = "status.update_performance";

  /// The direction of the performance measurement. Either 'download', for
  /// download measurements, or 'upload' for upload measurements.
  std::string direction = "";

  /// Seconds elapsed since the performance measurement was started.
  double elapsed = 0.0;

  /// Number of parallel TCP streams being used.
  int64_t num_streams = 0;

  /// Speed measured in kbit/s.
  double speed_kbps = 0.0;
};

}  // namespace event

/// Scalar options controlling the behavior of a nettest. If none of
/// these options are specified, the default values are used.
class Options {
 public:
  /// Base URL of the OONI bouncer. This base URL is used to construct the full
  /// URL required to contact the OONI bouncer and get test specific info like
  /// test helpers and test collectors.
  std::string bouncer_base_url = "https://bouncer.ooni.io";

  /// Base URL of the OONI collector. This base URL is used to construct the
  /// full URL required to contact manage the report submission with the
  /// collector. By default this option is not set because we use the bouncer to
  /// retrieve the collector base URL.
  std::string collector_base_url = "";

  /// DNS resolver IP address. By setting this option you will force MK to use
  /// that DNS resolver for resolving domain names to IP addresses. For this
  /// setting to work you should use a DNS engine different from the "system"
  /// engine.
  std::string dns_nameserver = "";

  /// What DNS engine to use. The "system" engine implies that `getaddrinfo()`
  /// is used. If you set this setting to "libevent" and you also configure the
  /// "dns/nameserver" option, MK will use libevent and the specified nameserver
  /// to resolve domain names.
  std::string dns_engine = "system";

  /// Path to the GeoIP ASN database file.
  std::string geoip_asn_path = "";

  /// Path to the GeoIP country database file.
  std::string geoip_country_path = "";

  /// Whether to ignore bouncer errors. If this option is true, then MK will not
  /// stop after failing to contact the OONI bouncer. Without the information
  /// provided by the bouncer, some tests MAY still work, while others (e.g.
  /// OONI tests) will most likely fail.
  double ignore_bouncer_error = true;

  /// Whether to ignore errors opening the report with the OONI collector.
  double ignore_open_report_error = true;

  /// Max run time for nettests taking input. When you are running a nettest
  /// taking input, the test will stop after the number of seconds specified by
  /// this option has passed.
  double max_runtime = -1.0;

  /// Path to the CA used to validate SSL certificates. This is not necessary
  /// where we use LibreSSL, because in such cases we include a CA bundle
  /// directly inside of the MK binary. This happens for Android, iOS, and
  /// Windows systems.
  std::string net_ca_bundle_path = "";

  /// Number of seconds after which I/O will timeout
  double net_timeout = 10.0;

  /// Whether to avoid using a bouncer
  double no_bouncer = false;

  /// Whether to avoid using a collector
  double no_collector = false;

  /// Whether to avoid the the probe ASN lookup.
  double no_asn_lookup = false;

  /// Whether to avoid the probe CC lookup.
  double no_cc_lookup = false;

  /// Whether to avoid looking up the probe IP. Not knowing the probe IP
  /// prevents us from looking up the ASN and the CC and also prevents us from
  /// attempting to scrub the IP address from measurements results.
  double no_ip_lookup = false;

  /// Whether to avoid writing a report file to disk.
  double no_file_report = false;

  /// Whether to avoid looking up the resolver IP address.
  double no_resolver_lookup = false;

  /// The ASN in which we are. If you set this, we will of course skip the probe
  /// ASN lookup.
  std::string probe_asn = "";

  /// The country code in which we are. If you set this, we will of course skip
  /// the probe CC lookup.
  std::string probe_cc = "";

  /// The probe IP. If you set this, we will of course skip the probe IP lookup
  std::string probe_ip = "";

  /// Whether to randomize the provided input.
  double randomize_input = true;

  /// Whether to save the probe ASN in the report.
  double save_real_probe_asn = true;

  /// Whether to save the probe country code in the report.
  double save_real_probe_cc = true;

  /// Whether to save the probe IP in the report.
  double save_real_probe_ip = false;

  /// Whether to save the probe resolver IP in the report.
  double save_real_resolver_ip = true;

  /// Name of the application. If this is not set, the string "measurement_kit"
  /// will be used.
  std::string software_name = "";

  /// Version of the application. If this is not set, the current MK version
  /// will be used.
  std::string software_version = "";
};

/// Settings specifying what test to run, with what input, etc.
class Settings {
 public:
  /// Optional annotations (i.e. key, value string pairs) that will be included
  /// into the JSON report sent to the OONI collector.
  std::map<std::string, std::string> annotations = {};

  /// List of events that will not be emitted.
  std::vector<std::string> disabled_events = {};

  /// Name of the test.
  std::string name = "";

  /// Options controlling the behavior of a nettest.
  Options options = {};
};

/// Contains the name of implemented nettests.
namespace nettest_name {

/// Neubot's DASH test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-021-dash.md.
constexpr const char *dash = "Dash";

/// OONI's captive portal test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-010-captive-portal.md.
constexpr const char *captive_portal = "CaptivePortal";

/// OONI's DNS injection test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-012-dns-injection.md.
constexpr const char *dns_injection = "DnsInjection";

/// OONI's Facebook Messenger test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-019-facebook-messenger.md.
constexpr const char *facebook_messenger = "FacebookMessenger";

/// OONI's HTTP header field manipulation test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-006-header-field-manipulation.md.
constexpr const char *http_header_field_manipulation =
    "HttpHeaderFieldManipulation";

/// OONI's HTTP invalid request line test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-007-http-invalid-request-line.md.
constexpr const char *http_invalid_request_line = "HttpInvalidRequestLine";

/// OONI's meek fronted requests test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-014-meek-fronted-requests.md.
constexpr const char *meek_fronted_requests = "MeekFrontedRequests";

/// the multi NDT network performance test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-022-ndt.md.
constexpr const char *multi_ndt = "MultiNdt";

/// the NDT network performance test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-022-ndt.md.
constexpr const char *ndt = "Ndt";

/// OONI's TCP connect test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-008-tcp-connect.md.
constexpr const char *tcp_connect = "TcpConnect";

/// OONI's Telegram test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-020-telegram.md.
constexpr const char *telegram = "Telegram";

/// OONI's Web Connectivity test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-017-web-connectivity.md.
constexpr const char *web_connectivity = "WebConnectivity";

/// OONI's WhatsApp test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-018-whatsapp.md.
constexpr const char *whatsapp = "Whatsapp";

}  // namespace nettest_name

/// Contains the available log_levels.
namespace log_level {

/// Only emit error messages.
constexpr const char *err = "ERR";

/// Also emit warning messages.
constexpr const char *warning = "WARNING";

/// Also emit informational messages.
constexpr const char *info = "INFO";

/// Also emit debug messages.
constexpr const char *debug = "DEBUG";

/// Emit all log messages.
constexpr const char *debug2 = "DEBUG2";

}  // namespace log_level

/// A network test.
class Nettest {
 public:
  /// Called when the FailureAsnLookup event occurs.
  virtual void on_failure_asn_lookup(const event::FailureAsnLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusUpdatePerformance event occurs.
  virtual void on_status_update_performance(
      const event::StatusUpdatePerformance &) {
    // TODO: override this callback if you're interested
  }

  /// Create a nettest using the specified settings.
  explicit Nettest(Settings s) noexcept { std::swap(s, settings_); }

  /// Runs the nettest until completion.
  void run();

  /// Releases allocated resources.
  virtual ~Nettest() noexcept;

 private:
  Settings settings_;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can include by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#ifndef MK_NETTEST_NO_INLINE_IMPL

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

Nettest::~Nettest() noexcept {}

void Nettest::run() {
  UniqueTask task;
  {
    nlohmann::json s;
    s["annotations"] = settings_.annotations;
    s["disabled_events"] = settings_.disabled_events;
    s["name"] = settings_.name;
    s["options"] = settings_.options;
    {
      nlohmann::json so;
      Options &opts = settings_.options;
      so["bouncer_base_url"] = opts.bouncer_base_url;
      so["collector_base_url"] = opts.collector_base_url;
      so["dns/nameserver"] = opts.dns_nameserver;
      so["dns/engine"] = opts.dns_engine;
      so["geoip_asn_path"] = opts.geoip_asn_path;
      so["geoip_country_path"] = opts.geoip_country_path;
      so["ignore_bouncer_error"] = (int64_t)opts.ignore_bouncer_error;
      so["ignore_open_report_error"] = (int64_t)opts.ignore_open_report_error;
      so["max_runtime"] = opts.max_runtime;
      so["net/ca_bundle_path"] = opts.net_ca_bundle_path;
      so["net/timeout"] = opts.net_timeout;
      so["no_bouncer"] = (int64_t)opts.no_bouncer;
      so["no_collector"] = (int64_t)opts.no_collector;
      so["no_asn_lookup"] = (int64_t)opts.no_asn_lookup;
      so["no_cc_lookup"] = (int64_t)opts.no_cc_lookup;
      so["no_ip_lookup"] = (int64_t)opts.no_ip_lookup;
      so["no_file_report"] = (int64_t)opts.no_file_report;
      so["no_resolver_lookup"] = (int64_t)opts.no_resolver_lookup;
      so["probe_asn"] = opts.probe_asn;
      so["probe_cc"] = opts.probe_cc;
      so["probe_ip"] = opts.probe_ip;
      so["randomize_input"] = (int64_t)opts.randomize_input;
      so["save_real_probe_asn"] = (int64_t)opts.save_real_probe_asn;
      so["save_real_probe_cc"] = (int64_t)opts.save_real_probe_cc;
      so["save_real_probe_ip"] = (int64_t)opts.save_real_probe_ip;
      so["save_real_resolver_ip"] = (int64_t)opts.save_real_resolver_ip;
      so["software_name"] = opts.software_name;
      so["software_version"] = opts.software_version;
      s["options"] = so;
    }
    task.reset(mk_task_start(s.dump().c_str()));
    if (!task) {
      throw std::runtime_error("mk_task_start() failed");
    }
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
      ev = nlohmann::json::parse(str);
    }
    if (ev.at("key") == "failure.asn_lookup") {
      event::FailureAsnLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_asn_lookup(event);
      continue;
    }
    if (ev.at("key") == "status.update_performance") {
      event::StatusUpdatePerformance event;
      event.direction = ev.at("value").at("direction");
      event.elapsed = ev.at("value").at("elapsed");
      event.num_streams = ev.at("value").at("num_streams");
      event.speed_kbps = ev.at("value").at("speed_kbps");
      on_status_update_performance(event);
      continue;
    }
    std::clog << "unhandled event: " << ev.at("key");
  }
}
#endif  // MK_NETTEST_NO_INLINE_IMPL

}  // namespace nettest
}  // namespace mk
#endif  // MEASUREMENT_KIT_NETTEST_NETTEST_HPP
