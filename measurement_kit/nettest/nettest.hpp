// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// \file include/measurement_kit/nettest/nettest.hpp
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.

#include <stdint.h>

#include <iostream>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include <measurement_kit/ffi/ffi.h>
#include <nlohmann/json.hpp>

/// Namespace containing MK code.
namespace mk {

/// Namespace containing the nettest API.
namespace nettest {

/// Contains the available log_levels.
namespace log_level {

/// Only emit error messages.
constexpr const char *err = "ERR";

/// Also emit warning messages.
constexpr const char *warning = "WARNING";

/// Also emit informational messages.
constexpr const char *info = "INFO";

/// Also emit debug messages.
constexpr const char *debug = "DEBUG";

/// Emit all log messages.
constexpr const char *debug2 = "DEBUG2";

}  // namespace log_level

/// Contains all the events emitted by nettests.
namespace event {

/// We could not lookup the ASN from the probe IP.
class FailureAsnLookup {
 public:
  /// The key that uniquely identifies an event. You can pass use this key
  /// with Settings to disable this specific event.
  static constexpr const char *event_key = "failure.asn_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// Status update regarding the currently ongoing network performance
/// measurement. This event is, of course, only emitted by network tests that
/// measure the network performance.
class StatusUpdatePerformance {
 public:
  /// The key that uniquely identifies an event. You can pass use this key
  /// with Settings to disable this specific event.
  static constexpr const char *event_key = "status.update_performance";

  /// The direction of the performance measurement. Either 'download', for
  /// download measurements, or 'upload' for upload measurements.
  std::string direction = "";

  /// Seconds elapsed since the performance measurement was started.
  double elapsed = 0.0;

  /// Number of parallel TCP streams being used.
  int64_t num_streams = 0;

  /// Speed measured in kbit/s.
  double speed_kbps = 0.0;
};

}  // namespace event

class Options {
 public:
  /// Base URL of the OONI bouncer. This base URL is used to construct the full
  /// URL required to contact the OONI bouncer and get test specific info like
  /// test helpers and test collectors.
  std::string bouncer_base_url = "https://bouncer.ooni.io";

  /// Base URL of the OONI collector. This base URL is used to construct the
  /// full URL required to contact manage the report submission with the
  /// collector. By default this option is not set because we use the bouncer to
  /// retrieve the collector base URL.
  std::string collector_base_url = "";

  /// DNS resolver IP address. By setting this option you will force MK to use
  /// that DNS resolver for resolving domain names to IP addresses. For this
  /// setting to work you should use a DNS engine different from the "system"
  /// engine.
  std::string dns_nameserver = "";

  /// What DNS engine to use. The "system" engine implies that `getaddrinfo()`
  /// is used. If you set this setting to "libevent" and you also configure the
  /// "dns/nameserver" option, MK will use libevent and the specified nameserver
  /// to resolve domain names.
  std::string dns_engine = "system";

  /// Path to the GeoIP ASN database file.
  std::string geoip_asn_path = "";

  /// Path to the GeoIP country database file.
  std::string geoip_country_path = "";

  /// Whether to ignore bouncer errors. If this option is true, then MK will not
  /// stop after failing to contact the OONI bouncer. Without the information
  /// provided by the bouncer, some tests MAY still work, while others (e.g.
  /// OONI tests) will most likely fail.
  double ignore_bouncer_error = true;

  /// Whether to ignore errors opening the report with the OONI collector.
  double ignore_open_report_error = true;

  /// Max run time for nettests taking input. When you are running a nettest
  /// taking input, the test will stop after the number of seconds specified by
  /// this option has passed.
  double max_runtime = -1.0;

  /// Path to the CA used to validate SSL certificates. This is not necessary
  /// where we use LibreSSL, because in such cases we include a CA bundle
  /// directly inside of the MK binary. This happens for Android, iOS, and
  /// Windows systems.
  std::string net_ca_bundle_path = "";

  /// Number of seconds after which I/O will timeout
  double net_timeout = 10.0;

  /// Whether to avoid using a bouncer
  double no_bouncer = false;

  /// Whether to avoid using a collector
  double no_collector = false;

  /// Whether to avoid the the probe ASN lookup.
  double no_asn_lookup = false;

  /// Whether to avoid the probe CC lookup.
  double no_cc_lookup = false;

  /// Whether to avoid looking up the probe IP. Not knowing the probe IP
  /// prevents us from looking up the ASN and the CC and also prevents us from
  /// attempting to scrub the IP address from measurements results.
  double no_ip_lookup = false;

  /// Whether to avoid writing a report file to disk.
  double no_file_report = false;

  /// Whether to avoid looking up the resolver IP address.
  double no_resolver_lookup = false;

  /// The ASN in which we are. If you set this, we will of course skip the probe
  /// ASN lookup.
  std::string probe_asn = "";

  /// The country code in which we are. If you set this, we will of course skip
  /// the probe CC lookup.
  std::string probe_cc = "";

  /// The probe IP. If you set this, we will of course skip the probe IP lookup
  std::string probe_ip = "";

  /// Whether to randomize the provided input.
  double randomize_input = true;

  /// Whether to save the probe ASN in the report.
  double save_real_probe_asn = true;

  /// Whether to save the probe country code in the report.
  double save_real_probe_cc = true;

  /// Whether to save the probe IP in the report.
  double save_real_probe_ip = false;

  /// Whether to save the probe resolver IP in the report.
  double save_real_resolver_ip = true;

  /// Name of the application. If this is not set, the string "measurement_kit"
  /// will be used.
  std::string software_name = "";

  /// Version of the application. If this is not set, the current MK version
  /// will be used.
  std::string software_version = "";
};

class Settings : public Options {
 public:
  /// Optional annotations (i.e. key, value string pairs) that will be included
  /// into the JSON report sent to the OONI collector.
  std::map<std::string, std::string> annotations = {};

  /// List of events that will not be emitted.
  std::vector<std::string> disabled_events = {};

  /// Name of the test.
  std::string name = "";

  /// Options controlling the behavior of a nettest.
  Options options = {};

  /// Releases allocated resources.
  virtual ~Settings() noexcept;

 protected:
  friend class Runner;
  virtual void serialize_into(nlohmann::json &doc) const;
};

/// Settings for Neubot's DASH test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-021-dash.md.
using DashSettings = Settings;

/// Settings for OONI's captive portal test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-010-captive-portal.md.
using CaptivePortalSettings = Settings;

/// Settings for OONI's DNS injection test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-012-dns-injection.md.
using DnsInjectionSettings = Settings;

/// Settings for OONI's Facebook Messenger test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-019-facebook-messenger.md.
using FacebookMessengerSettings = Settings;

/// Settings for OONI's HTTP header field manipulation test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-006-header-field-manipulation.md.
using HttpHeaderFieldManipulationSettings = Settings;

/// Settings for OONI's HTTP invalid request line test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-007-http-invalid-request-line.md.
using HttpInvalidRequestLineSettings = Settings;

/// Settings for OONI's meek fronted requests test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-014-meek-fronted-requests.md.
using MeekFrontedRequestsSettings = Settings;

/// Settings for the multi NDT network performance test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-022-ndt.md.
using MultiNdtSettings = Settings;

/// Settings for the NDT network performance test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-022-ndt.md.
using NdtSettings = Settings;

/// Settings for OONI's TCP connect test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-008-tcp-connect.md.
using TcpConnectSettings = Settings;

/// Settings for OONI's Telegram test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-020-telegram.md.
using TelegramSettings = Settings;

/// Settings for OONI's Web Connectivity test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-017-web-connectivity.md.
using WebConnectivitySettings = Settings;

/// Settings for OONI's WhatsApp test. For more info see
/// https://github.com/ooni/spec/blob/master/test-specs/ts-018-whatsapp.md.
class WhatsappSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether to check all WhatsApp endpoints.
  double all_endpoints = false;

  /// Release the allocated resources.
  ~WhatsappSettings() noexcept override;

 protected:
  void serialize_into(nlohmann::json &doc) const override;
};

/// Runs network tests and routes their events.
class Runner {
 public:
  /// Called when the FailureAsnLookup event occurs.
  virtual void on_failure_asn_lookup(const event::FailureAsnLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusUpdatePerformance event occurs.
  virtual void on_status_update_performance(
      const event::StatusUpdatePerformance &) {
    // TODO: override this callback if you're interested
  }

  /// Default constructor.
  Runner() noexcept {}

  /// Runs the nettest until completion.
  void run(const Settings &settings);

  /// Releases allocated resources.
  virtual ~Runner() noexcept;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can include by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#ifndef MK_NETTEST_NO_INLINE_IMPL

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

Settings::~Settings() noexcept {}

void Settings::serialize_into(nlohmann::json &doc) const {
  doc["annotations"] = annotations;
  doc["disabled_events"] = disabled_events;
  doc["name"] = name;
  doc["options"] = options;
  {
    nlohmann::json so;
    so["bouncer_base_url"] = bouncer_base_url;
    so["collector_base_url"] = collector_base_url;
    so["dns/nameserver"] = dns_nameserver;
    so["dns/engine"] = dns_engine;
    so["geoip_asn_path"] = geoip_asn_path;
    so["geoip_country_path"] = geoip_country_path;
    so["ignore_bouncer_error"] = (int64_t)ignore_bouncer_error;
    so["ignore_open_report_error"] = (int64_t)ignore_open_report_error;
    so["max_runtime"] = max_runtime;
    so["net/ca_bundle_path"] = net_ca_bundle_path;
    so["net/timeout"] = net_timeout;
    so["no_bouncer"] = (int64_t)no_bouncer;
    so["no_collector"] = (int64_t)no_collector;
    so["no_asn_lookup"] = (int64_t)no_asn_lookup;
    so["no_cc_lookup"] = (int64_t)no_cc_lookup;
    so["no_ip_lookup"] = (int64_t)no_ip_lookup;
    so["no_file_report"] = (int64_t)no_file_report;
    so["no_resolver_lookup"] = (int64_t)no_resolver_lookup;
    so["probe_asn"] = probe_asn;
    so["probe_cc"] = probe_cc;
    so["probe_ip"] = probe_ip;
    so["randomize_input"] = (int64_t)randomize_input;
    so["save_real_probe_asn"] = (int64_t)save_real_probe_asn;
    so["save_real_probe_cc"] = (int64_t)save_real_probe_cc;
    so["save_real_probe_ip"] = (int64_t)save_real_probe_ip;
    so["save_real_resolver_ip"] = (int64_t)save_real_resolver_ip;
    so["software_name"] = software_name;
    so["software_version"] = software_version;
    doc["options"] = so;
  }
}

Runner::~Runner() noexcept {}

WhatsappSettings::~WhatsappSettings() noexcept {}

void WhatsappSettings::serialize_into(nlohmann::json &doc) const {
  Settings::serialize_into(doc);
  doc["options"]["all_endpoints"] = (int64_t)all_endpoints;
}

void Runner::run(const Settings &settings) {
  UniqueTask task;
  {
    nlohmann::json s;
    settings.serialize_into(s);
    task.reset(mk_task_start(s.dump().c_str()));
    if (!task) {
      throw std::runtime_error("mk_task_start() failed");
    }
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
      ev = nlohmann::json::parse(str);
    }
    if (ev.at("key") == "failure.asn_lookup") {
      event::FailureAsnLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_asn_lookup(event);
      continue;
    }
    if (ev.at("key") == "status.update_performance") {
      event::StatusUpdatePerformance event;
      event.direction = ev.at("value").at("direction");
      event.elapsed = ev.at("value").at("elapsed");
      event.num_streams = ev.at("value").at("num_streams");
      event.speed_kbps = ev.at("value").at("speed_kbps");
      on_status_update_performance(event);
      continue;
    }
    std::clog << "unhandled event: " << ev.at("key");
  }
}
#endif  // MK_NETTEST_NO_INLINE_IMPL

}  // namespace nettest
}  // namespace mk
#endif  // MEASUREMENT_KIT_NETTEST_NETTEST_HPP
