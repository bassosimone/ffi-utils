// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// \file include/measurement_kit/nettest/nettest.hpp
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.

#include <stdint.h>

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <utility>

#include <measurement_kit/ffi/ffi.h>
#include <nlohmann/json.hpp>

/// Namespace containing MK code.
namespace mk {

/// Namespace containing the nettest API.
namespace nettest {

/// Contains the available log_levels.
namespace log_level {
{% for log_level in log_levels %}
/// {{ log_level.docs }}.
constexpr const char *{{ log_level.key.to_snake_case() }} = "{{ log_level.key.to_snake_case_upper() }}";
{% endfor %}
}  // namespace log_level

/// Contains all the events emitted by nettests.
namespace event {

{% for event in events %}
/// {{ event.docs }}
class {{ event.key.to_pascal_case() }} {
 public:
  /// The key that uniquely identifies an event. You can pass use this key
  /// with Settings to disable this specific event.
  static constexpr const char *event_key = "{{ event.key }}";

  {% for attribute in event.attributes %}
    /// {{ attribute.docs }}
    {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}
};
{% endfor %}

}  // namespace event

class Options {
 public:
  {% for attribute in options %}
    /// {{ attribute.docs }}
    {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}
};

class Settings : public Options {
 public:
  {% for attribute in settings %}
    /// {{ attribute.docs }}
    {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}

  /// Releases allocated resources.
  virtual ~Settings() noexcept;

 protected:
  friend class Runner;
  virtual void serialize_into(nlohmann::json &doc) const;
};

{% for nettest in nettests %}
  /// Settings for {{ nettest.docs }}. For more info see {{ nettest.reference_url }}.
  {% if nettest.options is not none %}class {{ nettest.key.to_pascal_case() }}Settings : public Settings {
     public:
      using Settings::Settings;

      {% for option in nettest.options %}
        /// {{ option.docs }}
        {{ option.base_type.decl("cxx") }} {{ option.key.to_snake_case() }} = {{ option.base_type.default_value("cxx") }};
      {% endfor %}

      /// Release the allocated resources.
      ~{{ nettest.key.to_pascal_case() }}Settings() noexcept override;

     protected:
       void serialize_into(nlohmann::json &doc) const override;
    };
  {% else %} using {{ nettest.key.to_pascal_case() }}Settings = Settings; {% endif %}
{% endfor %}

/// Runs network tests and routes their events.
class Runner {
 public:
  {% for event in events %}
    /// Called when the {{ event.key.to_pascal_case() }} event occurs.
    virtual void on_{{ event.key.to_snake_case() }}(const event::{{ event.key.to_pascal_case() }} &) {
      // TODO: override this callback if you're interested
    }
  {% endfor %}

  /// Default constructor.
  Runner() noexcept {}

  /// Runs the nettest until completion.
  void run(const Settings &settings);

  /// Releases allocated resources.
  virtual ~Runner() noexcept;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can include by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#ifndef MK_NETTEST_NO_INLINE_IMPL

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

Settings::~Settings() noexcept {}

void Settings::serialize_into(nlohmann::json &doc) const {
  {% for attribute in settings if attribute.key != "options" %} doc["{{ attribute.key }}"] = {{ attribute.base_type.to_json_cast("cxx") }} {{ attribute.key.to_snake_case() }}; {% endfor %}
  {
    nlohmann::json so;
    {% for attribute in options %} so["{{ attribute.key }}"] = {{ attribute.base_type.to_json_cast("cxx") }} {{ attribute.key.to_snake_case() }}; {% endfor %}
    doc["options"] = so;
  }
}

Runner::~Runner() noexcept {}

{% for nettest in nettests %}
  {% if nettest.options is not none %}
    {{ nettest.key.to_pascal_case() }}Settings::~{{ nettest.key.to_pascal_case() }}Settings() noexcept {}

    void {{ nettest.key.to_pascal_case() }}Settings::serialize_into(nlohmann::json &doc) const {
      Settings::serialize_into(doc);
      {% for option in nettest.options %} doc["options"]["{{ option.key }}"] = {{ option.base_type.to_json_cast("cxx") }} {{ option.key.to_snake_case() }}; {% endfor %}
    }
  {% endif %}
{% endfor %}

void Runner::run(const Settings &settings) {
  UniqueTask task;
  {
    nlohmann::json s;
    settings.serialize_into(s);
    task.reset(mk_task_start(s.dump().c_str()));
    if (!task) {
      throw std::runtime_error("mk_task_start() failed");
    }
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
      ev = nlohmann::json::parse(str);
    }
    {% for event in events %}if (ev.at("key") == "{{ event.key }}") {
      event::{{ event.key.to_pascal_case() }} event;
      {% for attribute in event.attributes %} event.{{ attribute.key.to_snake_case() }} = {{ attribute.base_type.from_json_cast("cxx") }} ev.at("value").at("{{ attribute.key }}"); {% endfor %}
      on_{{ event.key.to_snake_case() }}(event);
      continue;
    }{% endfor %}
    std::clog << "unhandled event: " << ev.at("key");
  }
}
#endif  // MK_NETTEST_NO_INLINE_IMPL

}  // namespace nettest
}  // namespace mk
#endif  // MEASUREMENT_KIT_NETTEST_NETTEST_HPP
