// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// \file include/measurement_kit/nettest/nettest.hpp
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.

#include <stdint.h>

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <utility>

#include <measurement_kit/ffi.h>
#include <nlohmann/json.hpp>

/// Namespace containing MK code.
namespace mk {

/// Namespace containing the nettest API.
namespace nettest {

/// Contains all the events emitted by nettests.
namespace event {

{% for event in events %}
/// {{ event.docs }}
class {{ event.key.to_pascal_case() }} {
 public:
  /// The key that uniquely identifies an event. You can pass use this key
  /// with Settings to disable this specific event.
  constexpr const char *event_key = "{{ event.key }}";

  {% for attribute in event.attributes %}
    /// {{ attribute.docs }}
    {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}
};
{% endfor %}

}  // namespace event

/// Scalar options controlling the behavior of a nettest. If none of
/// these options are specified, the default values are used.
class Options {
 public:
  {% for attribute in options %}
    /// {{ attribute.docs }}
    {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}
};

/// Settings specifying what test to run, with what input, etc.
class Settings {
 public:
  {% for attribute in settings %}
    /// {{ attribute.docs }}
    {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}
};

/// Contains the name of implemented nettests.
namespace nettest_name {
{% for nettest in nettests %}
/// {{ nettest.docs }}. For more info see {{ nettest.reference_url }}.
constexpr const char *{{ nettest.key.to_snake_case() }} = "{{ nettest.key.to_pascal_case() }}";
{% endfor %}
}  // namespace nettest_name

/// Contains the available log_levels.
namespace log_level {
{% for log_level in log_levels %}
/// {{ log_level.docs }}.
constexpr const char *{{ log_level.key.to_snake_case() }} = "{{ log_level.key.to_snake_case_upper() }}";
{% endfor %}
}  // namespace log_level

/// A network test.
class Nettest {
 public:
  {% for event in events %}
    /// Called when the {{ event.key.to_pascal_case() }} event occurs.
    virtual void on_{{ event.key.to_snake_case() }}(const event::{{ event.key.to_pascal_case() }} &) {
      // TODO: override this callback if you're interested
    }
  {% endfor %}

  /// Create a nettest using the specified settings.
  explicit Nettest(Settings s) noexcept { std::swap(s, settings_); }

  /// Runs the nettest until completion.
  void run();

  /// Releases allocated resources.
  virtual ~Nettest() noexcept;

 private:
  Settings settings_;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can include by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#ifndef MK_NETTEST_NO_INLINE_IMPL

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

Nettest::~Nettest() noexcept {}

void Nettest::run() {
  UniqueTask task;
  {
    nlohmann::json s;
    {% for attribute in settings if attribute.key != "options" %} s["{{ attribute.key }}"] = {{ attribute.base_type.to_json_cast("cxx") }} settings_.{{ attribute.key.to_snake_case() }}; {% endfor %}
    {
      nlohmann::json so;
      Options &opts = settings_.options;
      {% for attribute in options %} so["{{ attribute.key }}"] = {{ attribute.base_type.to_json_cast("cxx") }} opts.{{ attribute.key.to_snake_case() }}; {% endfor %}
      s["options"] = so;
    }
    task.reset(mk_task_start(s.dump().c_str()));
    if (!task) {
      throw std::runtime_error("mk_task_start() failed");
    }
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
      ev = nlohmann::json::parse(str);
    }
    {% for event in events %}if (ev.at("key") == "{{ event.key }}") {
      event::{{ event.key.to_pascal_case() }} event;
      {% for attribute in event.attributes %} event.{{ attribute.key.to_snake_case() }} = {{ attribute.base_type.from_json_cast("cxx") }} ev.at("value").at("{{ attribute.key }}"); {% endfor %}
      on_{{ event.key.to_snake_case() }}(event);
      continue;
    }{% endfor %}
    std::clog << "unhandled event: " << ev.at("key");
  }
}
#endif  // MK_NETTEST_NO_INLINE_IMPL

}  // namespace nettest
}  // namespace mk
#endif  // MEASUREMENT_KIT_NETTEST_NETTEST_HPP
