// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_CXX11_HPP

// WARNING: autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!

#include <stdint.h>

#include <map>
#include <string>
#include <vector>

#include <measurement_kit/ffi.h>
#include <nlohmann/json.hpp>

namespace mk {
namespace cxx11 {

{% for event in events %}/// {{ event.docs }}
class {{ event.key.to_pascal_case() }}Event {
 public:{% for attribute in event.attributes %}
  /// {{ attribute.docs }}
  {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}
};

{% endfor %}
/// Scalar options controlling the behavior of a nettest. If none of
/// these options are specified, the default values will, of course, be used.
class Options {
 public:{% for attribute in options %}
  /// {{ attribute.docs }}
  {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}

};

/// Settings specifying what test to run, with what input, etc.
class Settings {
 public:{% for attribute in settings %}
  /// {{ attribute.docs }}
  {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}

};

// XXX

/// Contains all the settings of a network test. The most important, and
/// the only mandatory field, is the network test `name`, that identifies what
/// test to run.
class Settings {
 public:
  /// Optional annotations that will be included into the report sent to
  /// the OONI collector.
  std::map<std::string, std::string> annotations;
  /// List of events that will not be delivered becasue you do not care
  /// about them.
  std::vector<std::string> disabled_events;
  /// Name of the test. This is a mandatory setting.
  std::string name = "";
  /// Scalar options controlling the behavior of a nettest.
  Options options;
};

/// A network test.
class Nettest {
 public:
  /// Callback called by run when FailureASNLookupEvent occurs.
  virtual void on_failure_asn_lookup(const FailureASNLookupEvent &) {
    // TODO: override
  }

  /// Callback called by run when StatusUpdatePerformanceEvent occurs.
  virtual void on_status_update_performance(
      const StatusUpdatePerformanceEvent &) {
    // TODO: override
  }

  /// Create a nettest using the specified settings.
  explicit Nettest(Settings s) noexcept { std::swap(s, settings_); }

  /// Runs the nettest until completion.
  void run();

  /// Releases allocated resources.
  virtual ~Nettest() noexcept;

 private:
  Settings settings_;
};

Nettest::~Nettest() noexcept {}

namespace internal {

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

}  // namespace internal

void Nettest::run() {
  nlohmann::json cxx_settings;
  {
    cxx_settings["annotations"] = settings_.annotations;
    cxx_settings["disabled_events"] = settings_.disabled_events;
    cxx_settings["name"] = settings_.name;
  }
  {
    cxx_settings["options"]["bouncer_base_url"] =
        settings_.options.bouncer_base_url;
    cxx_settings["options"]["dns/nameserver"] =
        settings_.options.dns_name_server;
    cxx_settings["options"]["ignore_bouncer_error"] =
        (settings_.options.ignore_bouncer_error) ? 1 : 0;
    cxx_settings["options"]["max_runtime"] = settings_.options.max_runtime;
  }
  internal::UniqueTask task{mk_task_start(cxx_settings.dump().c_str())};
  while (task) {
    nlohmann::json ev;
    {
      internal::UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        break;
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        break;
      }
      ev = nlohmann::json::parse(str);
    }
    if (ev.at("key") == "failure.asn_lookup") {
      FailureASNLookupEvent event;
      event.failure = ev.at("value").at("failure");
      on_failure_asn_lookup(event);
      continue;
    }
    if (ev.at("key") == "status.update_performance") {
      StatusUpdatePerformanceEvent event;
      event.direction = ev.at("value").at("direction");
      event.elapsed = ev.at("value").at("elapsed");
      event.num_streams = ev.at("value").at("num_streams");
      event.speed_kbps = ev.at("value").at("speed_kbps");
      on_status_update_performance(event);
      continue;
    }
  }
}

}  // namespace cxx11
}  // namespace mk
#endif  // MEASUREMENT_KIT_CXX11_HPP
