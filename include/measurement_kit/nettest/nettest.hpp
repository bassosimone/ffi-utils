// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// @file measurement_kit/nettest/nettest.hpp
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.
///
/// The core idea behind this API is that a network test (nettest) requires
/// some settings and will generate some events while running. Such events
/// could be, e.g., a log line, a piece of result.
///
/// As a general rule, use documented features. Undocumented features are
/// much more likely to be replaced or changed without notice.
///
/// Usage is as follows:
///
/// 1) Instantiate a settings class for the network test that you want
/// to run. For example:
///
/// ```
/// #include <measurement_kit/nettest/nettest.hpp>
///
/// mk::nettest::settings::Whatsapp settings;
/// ```
///
/// Then, configure all options for which you do not like the default and
/// supply the required parameters (e.g. input list for tests requiring input).
///
/// ```
/// settings.all_endpoints = true;
/// settings.log_level = settings.log_level_debug;
/// ```
///
/// There is a common base class for all settings that contains the options
/// settable by more than one nettest. This design should allow you to easily
/// write sections of code that set options common to many tests.
///
/// 2) Write a derived class of Runner where you override the virtual methods
/// handling the events that you would like to process. There is a single
/// runner allowing to run different nettests, such that you can use the same
/// class for different nettests, if that makes sense for your use case.
///
/// ```
/// class MyRunner : public mk::nettest::Runner {
///  public:
///   using mk::nettest::Runner::Runner;
///
///   void on_log(const mk::nettest::event::Log &evt) override {
///     std::clog << "<" << evt.log_level << ">" << evt.message << std::endl;
///   }
/// };
/// ```
///
/// 3) Instantiate your runner and run the test with your settings. To do that,
/// chain the prepare_NETTEST_NAME() and then run() methods.
///
/// ```
/// MyRunner runner;
/// // ...
/// runner.run(runner.prepare_whatsapp(settings));
/// ```
///
/// Note that prepare_NETTEST_NAME() and run() are two separate methods so that
/// you can prepare a nettest in nettest specific code and use common code to
/// actually execute it. That is:
///
/// ```
/// // Alternative example where runner.run() occurs much later.
/// MyRunner runner;
/// // ...
/// std::string serialized_config = runner.prepare_whatsapp(settings);
/// // ...
/// runner.run(serialized_config);
/// ```
///
/// Exceptions derived from `std::exception` MAY be emitted in case of serious
/// internal error. As such, it can probably make sense to just ignore them. If
/// an exception is thrown, the running network test is automatically stopped
/// and the related thread is joined.
///
/// @addtogroup nettest Nettest API
/// @brief C++11 API for running nettests.
/// @{

#include <assert.h>
#include <stdint.h>

#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

#include <measurement_kit/ffi.h>
#include <nlohmann/json.hpp>

/// Contains MK code.
namespace mk {

/// Contains the nettest API.
namespace nettest {

/// Contains the events classes. During its lifecycle, a network test emits
/// events in reaction to what happens. The Runner will call a specific
/// callback for any kind of event.
namespace event {

/// We could not lookup the ASN (Autonomous System Number) from the user's IP.
class FailureAsnLookup {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.asn_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// We could not lookup the country code from the user's IP.
class FailureCcLookup {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.cc_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// We could not lookup the user IP address.
class FailureIpLookup {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.ip_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure running the measurement.
class FailureMeasurement {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.measurement";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure in submitting the measurement result to the configured
/// collector.
class FailureMeasurementSubmission {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.measurement_submission";

  /// The specific error that occurred.
  std::string failure = "";

  /// Index of the measurement that failed
  int64_t idx = 0;

  /// Measurement that we could not submit as a serialized JSON.
  std::string json_str = "";
};

/// There was a failure in getting an ID for submitting results from the
/// configured collector.
class FailureReportCreate {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.report_create";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure in telling the configured collector that all the
/// measurements related to a specific ID have now been performed.
class FailureReportClose {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.report_close";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure attempting to lookup the user DNS resolver IP address.
class FailureResolverLookup {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.resolver_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure in starting the nettest, most likely because you passed
/// incorrect options. See the logs for more information of what went wrong.
class FailureStartup {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "failure.startup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// A log line that was emitted.
class Log {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "log";

  /// The log level as a string (e.g. "INFO").
  std::string log_level = "";

  /// The log message.
  std::string message = "";
};

/// The result of a measurement.
class Measurement {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "measurement";

  /// Index of the current measurement
  int64_t idx = 0;

  /// The measurement result as a serialized JSON.
  std::string json_str = "";
};

/// Event emitted once at the end of the nettest. This event is always emitted,
/// regardless of whether the nettest naturally reaches its end or is
/// interrupted. As such, you can rely on this event as a "once" suitable for
/// releasing all the extra resources you may have allocated as part of the
/// nettest lifecyle.
class StatusEnd {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.end";

  /// The number of KB downloaded during the test.
  double downloaded_kb = 0.0;

  /// The number of KB uploaded during the test.
  double uploaded_kb = 0.0;

  /// The error that occurred. If no error occurred, then this variable will
  /// hold an empty string.
  std::string failure = "";
};

/// Event emitted once, when we discover the geolocation of the user based on
/// their IP address.
class StatusGeoipLookup {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.geoip_lookup";

  /// The user IP address
  std::string probe_ip = "";

  /// The user ASN (Autonomous System Number)
  std::string probe_asn = "";

  /// The user country code (CC).
  std::string probe_cc = "";

  /// The descriptive name associated to the ASN
  std::string probe_network_name = "";
};

/// Emitted during the task lifecycle to indicate progress.
class StatusProgress {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.progress";

  /// Percentage of completion of the task.
  double percentage = 0.0;

  /// Optional message indicating what step is now complete.
  std::string message = "";
};

/// Emitted once to indicate that the tast has been submitted for running.
/// Unless you run multiple test at the same time (which is discouraged), this
/// event also implies that the test will be started immediately.
class StatusQueued {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.queued";
};

/// Emitted when we start a new measurement within a nettest. For nettests that
/// do not require input, there is just a single measurement within a nettest.
/// Otherwise, there is a measurement for each input provided to the nettest.
class StatusMeasurementStart {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.measurement_start";

  /// Index of the current measurement.
  int64_t idx = 0;

  /// Input of the current measurement. For nettests that do not take input,
  /// this will be the empty string.
  std::string input = "";
};

/// Emitted when the result of a measurement has been successfully submitted to
/// the configured collector.
class StatusMeasurementSubmission {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.measurement_submission";

  /// Index of the current measurement.
  int64_t idx = 0;
};

/// Emitted when a measurement is done. This is emitted regardless of whether
/// there were any failures during the measurement.
class StatusMeasurementDone {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.measurement_done";

  /// Index of the current measurement.
  int64_t idx = 0;
};

/// Emitted when we have notified the collector that we are done with running
/// measurements with a specific report ID.
class StatusReportClose {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.report_close";

  /// Unique identifier of the nettest with the collector.
  std::string report_id = "";
};

/// Emitted when we have notified the collector the intention to start
/// submitting measurements. As part of this API call, we receive back a "report
/// ID" to be used to submit subsequent measurements that we perform.
class StatusReportCreate {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.report_create";

  /// Unique identifier of the nettest with the collector.
  std::string report_id = "";
};

/// Emitted once when we discover the user DNS resolver IP.
class StatusResolverLookup {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.resolver_lookup";

  /// IP address of the user resolver.
  std::string ip_address = "";
};

/// Emitted once when the nettest has started running.
class StatusStarted {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.started";
};

/// Status update regarding the currently ongoing network performance
/// measurement. This event is, of course, only emitted by network tests that
/// measure the network performance.
class StatusUpdatePerformance {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.update.performance";

  /// The direction of the performance measurement. Either 'download', for
  /// download measurements, or 'upload' for upload measurements.
  std::string direction = "";

  /// Seconds elapsed since the performance measurement was started.
  double elapsed = 0.0;

  /// Number of parallel TCP streams being used.
  int64_t num_streams = 0;

  /// Speed measured in kbit/s.
  double speed_kbps = 0.0;
};

/// Status update regarding the currently ongoing website censorship
/// measurement.
class StatusUpdateWebsites {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "status.update.websites";

  /// URL that we are measuring.
  std::string url = "";

  /// Result of the measurement. Either "accessible" or "blocking".
  std::string status = "";
};

/// Emitted when a nettest is done and you attempt using the FFI API to extract
/// more tasks from its queue.
class TaskTerminated {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "task_terminated";
};

}  // namespace event

/// Contains the settings classes.
namespace settings {

/// Settings common to all network tests.
class Common {
 public:
  /// Only emit error messages.
  static constexpr const char *log_level_err = "ERR";

  /// Also emit warning messages.
  static constexpr const char *log_level_warning = "WARNING";

  /// Also emit informational messages.
  static constexpr const char *log_level_info = "INFO";

  /// Also emit debug messages.
  static constexpr const char *log_level_debug = "DEBUG";

  /// Emit all log messages.
  static constexpr const char *log_level_debug2 = "DEBUG2";

  /// Optional annotations (i.e. key, value string pairs) that will be included
  /// into the JSON report sent to the OONI collector.
  std::map<std::string, std::string> annotations = {};

  /// List of events that will not be emitted.
  std::vector<std::string> disabled_events = {};

  /// List of URLs or domains required by the test.
  std::vector<std::string> inputs = {};

  /// List of files from which to read inputs.
  std::vector<std::string> input_filepaths = {};

  /// File where to write log messages.
  std::string log_filepath = "";

  /// Type of log messages you are interested into.
  std::string log_level = "ERR";

  /// File where to write the nettest results.
  std::string output_filepath = "";

  /// Base URL of the OONI bouncer. This base URL is used to construct the full
  /// URL required to contact the OONI bouncer and get test specific info like
  /// test helpers and test collectors.
  std::string bouncer_base_url = "https://bouncer.ooni.io";

  /// Base URL of the OONI collector. This base URL is used to construct the
  /// full URL required to contact manage the report submission with the
  /// collector. By default this option is not set because we use the bouncer to
  /// retrieve the collector base URL.
  std::string collector_base_url = "";

  /// DNS resolver IP address. By setting this option you will force MK to use
  /// that DNS resolver for resolving domain names to IP addresses. For this
  /// setting to work you should use a DNS engine different from the "system"
  /// engine. By default this option is not set, as we use the system engine as
  /// our default DNS engine.
  std::string dns_nameserver = "";

  /// What DNS engine to use. The "system" engine implies that `getaddrinfo()`
  /// is used. If you set this setting to "libevent" and you also configure the
  /// "dns/nameserver" option, MK will use libevent and the specified nameserver
  /// to resolve domain names.
  std::string dns_engine = "system";

  /// Path to the GeoIP ASN (Autonomous System Number) database file. By default
  /// this option is empty. If you do not change this option to contain the path
  /// to a suitable database file, MK will not be able to map the user's IP
  /// address to an ASN.
  std::string geoip_asn_path = "";

  /// Path to the GeoIP country database file. By default this option is empty.
  /// If you do not change it to contain the path to a suitable database file,
  /// MK will not be able to map the user's IP to a country code.
  std::string geoip_country_path = "";

  /// Whether to ignore bouncer errors. If this option is true, then MK will not
  /// stop after failing to contact the OONI bouncer. Without the information
  /// provided by the bouncer, OONI tests that require a test helper will
  /// certainly fail, while other tests will just fail to submit their results
  /// to a collector, unless you manually configure a collector base URL.
  bool ignore_bouncer_error = true;

  /// Whether to ignore errors opening the report with the OONI collector.
  bool ignore_open_report_error = true;

  /// Max run time for nettests taking input. When you are running a nettest
  /// taking input, the test will stop after the number of seconds specified by
  /// this option has passed (plus some extra time required to interrupt the
  /// testing engine). Setting this option to a negative value lets the test run
  /// as long as necessary to exhaust its input list.
  double max_runtime = -1.0;

  /// Path to the CA used to validate SSL certificates. This is not necessary
  /// where we use LibreSSL, because in such cases we include a CA bundle
  /// directly inside of the MK binary. This happens for Android, iOS, and
  /// Windows systems. If this option is not set and we're not using LibreSSL,
  /// then attempting to connect to any website using HTTPS will fail.
  std::string net_ca_bundle_path = "";

  /// Number of seconds after which network I/O operations (i.e. connect, recv,
  /// send) will timeout and return an error.
  double net_timeout = 10.0;

  /// Whether to avoid using a bouncer. Not using a bouncer means we will not
  /// discover the base URL of a suitable collector and of test helpers. OONI
  /// tests that require test helpers will fail if you disable the bouncer.
  /// Other tests will just not be able to submit results to a collector, unless
  /// you manually configure a collector base URL.
  bool no_bouncer = false;

  /// Whether to avoid using a collector. If true, it means that the test
  /// results are not submitted to a collector (by default the OONI collector)
  /// for archival or publishing purposes. All measurements submitted to the
  /// OONI collector are published within a few business days.
  bool no_collector = false;

  /// Whether to avoid the the user's ASN (Autonomous System Number) lookup.
  bool no_asn_lookup = false;

  /// Whether to avoid the user's country code lookup.
  bool no_cc_lookup = false;

  /// Whether to avoid looking up the user's IP. Not knowing it prevents us from
  /// looking up the ASN (Autonomous System Number) and the country code. Most
  /// importantly, this also prevents us from attempting to scrub the IP address
  /// from measurements results, which may be a concern for censorship tests.
  bool no_ip_lookup = false;

  /// Whether to avoid writing a report file to disk.
  bool no_file_report = false;

  /// Whether to avoid looking up the resolver IP address.
  bool no_resolver_lookup = false;

  /// The ASN (Autonomous System Number) in which we are. If you set this, we
  /// will of course skip the user's ASN lookup.
  std::string probe_asn = "";

  /// The country code in which we are. If you set this, we will of course skip
  /// the user's country code lookup.
  std::string probe_cc = "";

  /// The user's IP. If you set this, we will of course skip the user's IP
  /// lookup.
  std::string probe_ip = "";

  /// Whether to randomize the provided input.
  bool randomize_input = true;

  /// Whether to save the user's ASN (Autonomous System Number) in the report.
  bool save_real_probe_asn = true;

  /// Whether to save the user's country code in the report.
  bool save_real_probe_cc = true;

  /// Whether to save the user's IP in the report.
  bool save_real_probe_ip = false;

  /// Whether to save the user's resolver IP in the report.
  bool save_real_resolver_ip = true;

  /// Name of the application.
  std::string software_name = "measurement_kit";

  /// Version of the application. By default this is an empty string. If you do
  /// not set this variable, the current MK version will be used.
  std::string software_version = "";
};

/// Full settings for OONI's captive portal test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-010-captive-portal.md.
class CaptivePortal : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;
};

/// Full settings for Neubot's DASH test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-021-dash.md.
class Dash : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;
};

/// Full settings for OONI's DNS injection test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-012-dns-injection.md.
class DnsInjection : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = true;
};

/// Full settings for OONI's Facebook Messenger test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-019-facebook-messenger.md.
class FacebookMessenger : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;
};

/// Full settings for OONI's HTTP header field manipulation test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-006-header-field-manipulation.md.
class HttpHeaderFieldManipulation : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;
};

/// Full settings for OONI's HTTP invalid request line test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-007-http-invalid-request-line.md.
class HttpInvalidRequestLine : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;
};

/// Full settings for OONI's meek fronted requests test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-014-meek-fronted-requests.md.
class MeekFrontedRequests : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = true;
};

/// Full settings for the multi NDT network performance test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-022-ndt.md.
class MultiNdt : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;
};

/// Full settings for the NDT network performance test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-022-ndt.md.
class Ndt : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;
};

/// Full settings for OONI's TCP connect test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-008-tcp-connect.md.
class TcpConnect : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = true;
};

/// Full settings for OONI's Telegram test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-020-telegram.md.
class Telegram : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;
};

/// Full settings for OONI's Web Connectivity test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-017-web-connectivity.md.
class WebConnectivity : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = true;
};

/// Full settings for OONI's WhatsApp test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-018-whatsapp.md.
class Whatsapp : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  /// Whether to check all WhatsApp endpoints.
  bool all_endpoints = false;
};

}  // namespace settings

/// Runs network tests and routes their events.
class Runner {
 public:
  // Event handlers
  // --------------

  /// Called when the FailureAsnLookup event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_asn_lookup(const event::FailureAsnLookup &);

  /// Called when the FailureCcLookup event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_cc_lookup(const event::FailureCcLookup &);

  /// Called when the FailureIpLookup event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_ip_lookup(const event::FailureIpLookup &);

  /// Called when the FailureMeasurement event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_measurement(const event::FailureMeasurement &);

  /// Called when the FailureMeasurementSubmission event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_measurement_submission(
      const event::FailureMeasurementSubmission &);

  /// Called when the FailureReportCreate event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_report_create(const event::FailureReportCreate &);

  /// Called when the FailureReportClose event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_report_close(const event::FailureReportClose &);

  /// Called when the FailureResolverLookup event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_resolver_lookup(const event::FailureResolverLookup &);

  /// Called when the FailureStartup event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_failure_startup(const event::FailureStartup &);

  /// Called when the Log event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_log(const event::Log &);

  /// Called when the Measurement event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_measurement(const event::Measurement &);

  /// Called when the StatusEnd event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_end(const event::StatusEnd &);

  /// Called when the StatusGeoipLookup event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_geoip_lookup(const event::StatusGeoipLookup &);

  /// Called when the StatusProgress event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_progress(const event::StatusProgress &);

  /// Called when the StatusQueued event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_queued(const event::StatusQueued &);

  /// Called when the StatusMeasurementStart event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_measurement_start(
      const event::StatusMeasurementStart &);

  /// Called when the StatusMeasurementSubmission event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_measurement_submission(
      const event::StatusMeasurementSubmission &);

  /// Called when the StatusMeasurementDone event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_measurement_done(const event::StatusMeasurementDone &);

  /// Called when the StatusReportClose event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_report_close(const event::StatusReportClose &);

  /// Called when the StatusReportCreate event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_report_create(const event::StatusReportCreate &);

  /// Called when the StatusResolverLookup event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_resolver_lookup(const event::StatusResolverLookup &);

  /// Called when the StatusStarted event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_started(const event::StatusStarted &);

  /// Called when the StatusUpdatePerformance event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_update_performance(
      const event::StatusUpdatePerformance &);

  /// Called when the StatusUpdateWebsites event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_status_update_websites(const event::StatusUpdateWebsites &);

  /// Called when the TaskTerminated event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_task_terminated(const event::TaskTerminated &);

  // Runners
  // -------

  /// Prepare for running captive_portal until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_captive_portal(const settings::CaptivePortal &settings);

  /// Prepare for running dash until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_dash(const settings::Dash &settings);

  /// Prepare for running dns_injection until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_dns_injection(const settings::DnsInjection &settings);

  /// Prepare for running facebook_messenger until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_facebook_messenger(
      const settings::FacebookMessenger &settings);

  /// Prepare for running http_header_field_manipulation until completion.
  /// @return the string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_http_header_field_manipulation(
      const settings::HttpHeaderFieldManipulation &settings);

  /// Prepare for running http_invalid_request_line until completion. @return
  /// the string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_http_invalid_request_line(
      const settings::HttpInvalidRequestLine &settings);

  /// Prepare for running meek_fronted_requests until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_meek_fronted_requests(
      const settings::MeekFrontedRequests &settings);

  /// Prepare for running multi_ndt until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_multi_ndt(const settings::MultiNdt &settings);

  /// Prepare for running ndt until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_ndt(const settings::Ndt &settings);

  /// Prepare for running tcp_connect until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_tcp_connect(const settings::TcpConnect &settings);

  /// Prepare for running telegram until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_telegram(const settings::Telegram &settings);

  /// Prepare for running web_connectivity until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_web_connectivity(
      const settings::WebConnectivity &settings);

  /// Prepare for running whatsapp until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_whatsapp(const settings::Whatsapp &settings);

  /// Run the nettest identified by @p s. @param s should be a string
  /// returned to you by one of the prepare_NETTEST_NAME() methods. @throw
  /// std::exception when it is not possible to marshal/unmarshal data
  /// structures from/to JSON as well on internal errors.
  void run(std::string s);

  // Misc
  // ----

  Runner() noexcept;

  virtual ~Runner() noexcept;

 private:
  std::string prepare_common(nlohmann::json &&doc,
                             const settings::Common &common);
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can exclude by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#if !defined MK_NETTEST_NO_INLINE_IMPL && !defined SWIG

// Utility classes
// ---------------

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

// Empty event handlers
// --------------------

void Runner::on_failure_asn_lookup(const event::FailureAsnLookup &) {}

void Runner::on_failure_cc_lookup(const event::FailureCcLookup &) {}

void Runner::on_failure_ip_lookup(const event::FailureIpLookup &) {}

void Runner::on_failure_measurement(const event::FailureMeasurement &) {}

void Runner::on_failure_measurement_submission(
    const event::FailureMeasurementSubmission &) {}

void Runner::on_failure_report_create(const event::FailureReportCreate &) {}

void Runner::on_failure_report_close(const event::FailureReportClose &) {}

void Runner::on_failure_resolver_lookup(const event::FailureResolverLookup &) {}

void Runner::on_failure_startup(const event::FailureStartup &) {}

void Runner::on_log(const event::Log &) {}

void Runner::on_measurement(const event::Measurement &) {}

void Runner::on_status_end(const event::StatusEnd &) {}

void Runner::on_status_geoip_lookup(const event::StatusGeoipLookup &) {}

void Runner::on_status_progress(const event::StatusProgress &) {}

void Runner::on_status_queued(const event::StatusQueued &) {}

void Runner::on_status_measurement_start(
    const event::StatusMeasurementStart &) {}

void Runner::on_status_measurement_submission(
    const event::StatusMeasurementSubmission &) {}

void Runner::on_status_measurement_done(const event::StatusMeasurementDone &) {}

void Runner::on_status_report_close(const event::StatusReportClose &) {}

void Runner::on_status_report_create(const event::StatusReportCreate &) {}

void Runner::on_status_resolver_lookup(const event::StatusResolverLookup &) {}

void Runner::on_status_started(const event::StatusStarted &) {}

void Runner::on_status_update_performance(
    const event::StatusUpdatePerformance &) {}

void Runner::on_status_update_websites(const event::StatusUpdateWebsites &) {}

void Runner::on_task_terminated(const event::TaskTerminated &) {}

// Preparing nettests
// ------------------

std::string Runner::prepare_captive_portal(
    const settings::CaptivePortal &settings) {
  nlohmann::json doc;
  doc["name"] = "CaptivePortal";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_dash(const settings::Dash &settings) {
  nlohmann::json doc;
  doc["name"] = "Dash";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_dns_injection(
    const settings::DnsInjection &settings) {
  nlohmann::json doc;
  doc["name"] = "DnsInjection";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_facebook_messenger(
    const settings::FacebookMessenger &settings) {
  nlohmann::json doc;
  doc["name"] = "FacebookMessenger";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_http_header_field_manipulation(
    const settings::HttpHeaderFieldManipulation &settings) {
  nlohmann::json doc;
  doc["name"] = "HttpHeaderFieldManipulation";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_http_invalid_request_line(
    const settings::HttpInvalidRequestLine &settings) {
  nlohmann::json doc;
  doc["name"] = "HttpInvalidRequestLine";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_meek_fronted_requests(
    const settings::MeekFrontedRequests &settings) {
  nlohmann::json doc;
  doc["name"] = "MeekFrontedRequests";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_multi_ndt(const settings::MultiNdt &settings) {
  nlohmann::json doc;
  doc["name"] = "MultiNdt";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_ndt(const settings::Ndt &settings) {
  nlohmann::json doc;
  doc["name"] = "Ndt";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_tcp_connect(const settings::TcpConnect &settings) {
  nlohmann::json doc;
  doc["name"] = "TcpConnect";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_telegram(const settings::Telegram &settings) {
  nlohmann::json doc;
  doc["name"] = "Telegram";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_web_connectivity(
    const settings::WebConnectivity &settings) {
  nlohmann::json doc;
  doc["name"] = "WebConnectivity";
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_whatsapp(const settings::Whatsapp &settings) {
  nlohmann::json doc;
  doc["name"] = "Whatsapp";
  doc["options"]["all_endpoints"] = (int64_t)settings.all_endpoints;
  return prepare_common(std::move(doc), settings);
}

std::string Runner::prepare_common(nlohmann::json &&doc,
                                   const settings::Common &cs) {
  doc["annotations"] = cs.annotations;
  doc["disabled_events"] = cs.disabled_events;
  doc["inputs"] = cs.inputs;
  doc["input_filepaths"] = cs.input_filepaths;
  doc["log_filepath"] = cs.log_filepath;
  doc["log_level"] = cs.log_level;
  doc["output_filepath"] = cs.output_filepath;
  {
    auto &o = doc["options"];
    o["bouncer_base_url"] = cs.bouncer_base_url;
    o["collector_base_url"] = cs.collector_base_url;
    o["dns/nameserver"] = cs.dns_nameserver;
    o["dns/engine"] = cs.dns_engine;
    o["geoip_asn_path"] = cs.geoip_asn_path;
    o["geoip_country_path"] = cs.geoip_country_path;
    o["ignore_bouncer_error"] = (int64_t)cs.ignore_bouncer_error;
    o["ignore_open_report_error"] = (int64_t)cs.ignore_open_report_error;
    o["max_runtime"] = cs.max_runtime;
    o["net/ca_bundle_path"] = cs.net_ca_bundle_path;
    o["net/timeout"] = cs.net_timeout;
    o["no_bouncer"] = (int64_t)cs.no_bouncer;
    o["no_collector"] = (int64_t)cs.no_collector;
    o["no_asn_lookup"] = (int64_t)cs.no_asn_lookup;
    o["no_cc_lookup"] = (int64_t)cs.no_cc_lookup;
    o["no_ip_lookup"] = (int64_t)cs.no_ip_lookup;
    o["no_file_report"] = (int64_t)cs.no_file_report;
    o["no_resolver_lookup"] = (int64_t)cs.no_resolver_lookup;
    o["probe_asn"] = cs.probe_asn;
    o["probe_cc"] = cs.probe_cc;
    o["probe_ip"] = cs.probe_ip;
    o["randomize_input"] = (int64_t)cs.randomize_input;
    o["save_real_probe_asn"] = (int64_t)cs.save_real_probe_asn;
    o["save_real_probe_cc"] = (int64_t)cs.save_real_probe_cc;
    o["save_real_probe_ip"] = (int64_t)cs.save_real_probe_ip;
    o["save_real_resolver_ip"] = (int64_t)cs.save_real_resolver_ip;
    o["software_name"] = cs.software_name;
    o["software_version"] = cs.software_version;
  }
  return doc.dump();
}

void Runner::run(std::string str) {
  UniqueTask task;
#ifdef MK_NETTEST_TRACE
  std::clog << "NETTEST: settings: " << str << std::endl;
#endif
  task.reset(mk_task_start(str.c_str()));
  if (!task) {
    throw std::runtime_error("mk_task_start() failed");
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
#ifdef MK_NETTEST_TRACE
      std::clog << "NETTEST: event: " << str << std::endl;
#endif
      ev = nlohmann::json::parse(str);
    }
    if (ev.at("key") == event::FailureAsnLookup::key) {
      event::FailureAsnLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_asn_lookup(event);
      continue;
    }
    if (ev.at("key") == event::FailureCcLookup::key) {
      event::FailureCcLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_cc_lookup(event);
      continue;
    }
    if (ev.at("key") == event::FailureIpLookup::key) {
      event::FailureIpLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_ip_lookup(event);
      continue;
    }
    if (ev.at("key") == event::FailureMeasurement::key) {
      event::FailureMeasurement event;
      event.failure = ev.at("value").at("failure");
      on_failure_measurement(event);
      continue;
    }
    if (ev.at("key") == event::FailureMeasurementSubmission::key) {
      event::FailureMeasurementSubmission event;
      event.failure = ev.at("value").at("failure");
      event.idx = ev.at("value").at("idx");
      event.json_str = ev.at("value").at("json_str");
      on_failure_measurement_submission(event);
      continue;
    }
    if (ev.at("key") == event::FailureReportCreate::key) {
      event::FailureReportCreate event;
      event.failure = ev.at("value").at("failure");
      on_failure_report_create(event);
      continue;
    }
    if (ev.at("key") == event::FailureReportClose::key) {
      event::FailureReportClose event;
      event.failure = ev.at("value").at("failure");
      on_failure_report_close(event);
      continue;
    }
    if (ev.at("key") == event::FailureResolverLookup::key) {
      event::FailureResolverLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_resolver_lookup(event);
      continue;
    }
    if (ev.at("key") == event::FailureStartup::key) {
      event::FailureStartup event;
      event.failure = ev.at("value").at("failure");
      on_failure_startup(event);
      continue;
    }
    if (ev.at("key") == event::Log::key) {
      event::Log event;
      event.log_level = ev.at("value").at("log_level");
      event.message = ev.at("value").at("message");
      on_log(event);
      continue;
    }
    if (ev.at("key") == event::Measurement::key) {
      event::Measurement event;
      event.idx = ev.at("value").at("idx");
      event.json_str = ev.at("value").at("json_str");
      on_measurement(event);
      continue;
    }
    if (ev.at("key") == event::StatusEnd::key) {
      event::StatusEnd event;
      event.downloaded_kb = ev.at("value").at("downloaded_kb");
      event.uploaded_kb = ev.at("value").at("uploaded_kb");
      event.failure = ev.at("value").at("failure");
      on_status_end(event);
      continue;
    }
    if (ev.at("key") == event::StatusGeoipLookup::key) {
      event::StatusGeoipLookup event;
      event.probe_ip = ev.at("value").at("probe_ip");
      event.probe_asn = ev.at("value").at("probe_asn");
      event.probe_cc = ev.at("value").at("probe_cc");
      event.probe_network_name = ev.at("value").at("probe_network_name");
      on_status_geoip_lookup(event);
      continue;
    }
    if (ev.at("key") == event::StatusProgress::key) {
      event::StatusProgress event;
      event.percentage = ev.at("value").at("percentage");
      event.message = ev.at("value").at("message");
      on_status_progress(event);
      continue;
    }
    if (ev.at("key") == event::StatusQueued::key) {
      event::StatusQueued event;
      on_status_queued(event);
      continue;
    }
    if (ev.at("key") == event::StatusMeasurementStart::key) {
      event::StatusMeasurementStart event;
      event.idx = ev.at("value").at("idx");
      event.input = ev.at("value").at("input");
      on_status_measurement_start(event);
      continue;
    }
    if (ev.at("key") == event::StatusMeasurementSubmission::key) {
      event::StatusMeasurementSubmission event;
      event.idx = ev.at("value").at("idx");
      on_status_measurement_submission(event);
      continue;
    }
    if (ev.at("key") == event::StatusMeasurementDone::key) {
      event::StatusMeasurementDone event;
      event.idx = ev.at("value").at("idx");
      on_status_measurement_done(event);
      continue;
    }
    if (ev.at("key") == event::StatusReportClose::key) {
      event::StatusReportClose event;
      event.report_id = ev.at("value").at("report_id");
      on_status_report_close(event);
      continue;
    }
    if (ev.at("key") == event::StatusReportCreate::key) {
      event::StatusReportCreate event;
      event.report_id = ev.at("value").at("report_id");
      on_status_report_create(event);
      continue;
    }
    if (ev.at("key") == event::StatusResolverLookup::key) {
      event::StatusResolverLookup event;
      event.ip_address = ev.at("value").at("ip_address");
      on_status_resolver_lookup(event);
      continue;
    }
    if (ev.at("key") == event::StatusStarted::key) {
      event::StatusStarted event;
      on_status_started(event);
      continue;
    }
    if (ev.at("key") == event::StatusUpdatePerformance::key) {
      event::StatusUpdatePerformance event;
      event.direction = ev.at("value").at("direction");
      event.elapsed = ev.at("value").at("elapsed");
      event.num_streams = ev.at("value").at("num_streams");
      event.speed_kbps = ev.at("value").at("speed_kbps");
      on_status_update_performance(event);
      continue;
    }
    if (ev.at("key") == event::StatusUpdateWebsites::key) {
      event::StatusUpdateWebsites event;
      event.url = ev.at("value").at("url");
      event.status = ev.at("value").at("status");
      on_status_update_websites(event);
      continue;
    }
    if (ev.at("key") == event::TaskTerminated::key) {
      event::TaskTerminated event;
      on_task_terminated(event);
      continue;
    }
    {
      std::stringstream reason;
      reason << "unhandled FFI event: " << ev.at("key");
      throw std::runtime_error(reason.str().c_str());
    }
  }
}

// Misc
// ----

Runner::Runner() noexcept {}

Runner::~Runner() noexcept {}

#endif  // !MK_NETTEST_NO_INLINE_IMPL && !SWIG
}  // namespace nettest
}  // namespace mk
/// @}
#endif  // MEASUREMENT_KIT_NETTEST_NETTEST_HPP
