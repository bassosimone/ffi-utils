// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// @file measurement_kit/nettest/nettest.hpp
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.
///
/// The core idea behind this API is that a network test (nettest) requires
/// some settings and will generate some events while running. Such events
/// could be, e.g., a log line, a piece of result.
///
/// As a general rule, use documented features. Undocumented features are
/// much more likely to be replaced or changed without notice.
///
/// Usage is as follows. Instantiate a settings class for the network test
/// that you want to execute. For example:
///
/// ```
/// #include <measurement_kit/nettest/nettest.hpp>
///
/// mk::nettest::settings::WebConnectivitySettings mySettings;
/// ```
///
/// Configure the settings you care about. Some settings are shared by all
/// network tests while others are nettest specific.
///
/// ```
/// mySettings.log_level = mk::nettest::log_levels::debug;
/// ```
///
/// Write a derived class of Runner where you override the virtual methods
/// handling the events that you would like to process.
///
/// ```
/// class MyRunner : public mk::nettest::Runner {
///  public:
///   using mk::nettest::Runner::Runner;
///
///   virtual void on_log(const mk::nettest::events::Log &evt) {
///     std::clog << "<" << evt.log_level << ">" << evt.message << std::endl;
///   }
/// };
/// ```
///
/// Instantiate your runner and run the test with your settings. Exceptions
/// derived from `std::exception` MAY be emitted in case of serious internal
/// error. You may want to be prepared for them.
///
/// ```
/// MyRunner runner;
/// try {
///   runner.run(mySettings);
/// } catch (const std::exception &exc) {
///   // TODO: handle
/// }
/// ```
///
/// @addtogroup nettest Nettest API
/// @brief C++11 API for running network tests.
/// @{

#include <assert.h>
#include <stdint.h>

#include <iostream>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include <measurement_kit/ffi/ffi.h>
#include <nlohmann/json.hpp>

/// Contains MK code.
namespace mk {

/// Contains the nettest API.
namespace nettest {

/// Contains the log levels. Use these values to initialize the
/// settings::Settings::log_level field.
namespace log_levels {

/// Only emit error messages.
constexpr const char *err = "ERR";

/// Also emit warning messages.
constexpr const char *warning = "WARNING";

/// Also emit informational messages.
constexpr const char *info = "INFO";

/// Also emit debug messages.
constexpr const char *debug = "DEBUG";

/// Emit all log messages.
constexpr const char *debug2 = "DEBUG2";

}  // namespace log_levels

/// Contains the events classes. During its lifecycle, a network test emits
/// events in reaction to what happens. The Runner will call a specific
/// callback for any kind of event.
namespace events {

/// We could not lookup the ASN (Autonomous System Number) from the user's IP.
class FailureAsnLookup {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.asn_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// We could not lookup the country code from the user's IP.
class FailureCcLookup {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.cc_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// We could not lookup the user IP address.
class FailureIpLookup {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.ip_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure running the measurement.
class FailureMeasurement {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.measurement";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure in submitting the measurement result to the configured
/// collector.
class FailureMeasurementSubmission {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.measurement_submission";

  /// The specific error that occurred.
  std::string failure = "";

  /// Index of the measurement that failed
  int64_t idx = 0;

  /// Measurement that we could not submit as a serialized JSON.
  std::string json_str = "";
};

/// There was a failure in getting an ID for submitting results from the
/// configured collector.
class FailureReportCreate {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.report_create";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure in telling the configured collector that all the
/// measurements related to a specific ID have now been performed.
class FailureReportClose {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.report_close";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure attempting to lookup the user DNS resolver IP address.
class FailureResolverLookup {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.resolver_lookup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// There was a failure in starting the nettest, most likely because you passed
/// incorrect options. See the logs for more information of what went wrong.
class FailureStartup {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "failure.startup";

  /// The specific error that occurred.
  std::string failure = "";
};

/// A log line that was emitted.
class Log {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "log";

  /// The log level as a string (e.g. "INFO").
  std::string log_level = "";

  /// The log message.
  std::string message = "";
};

/// The result of a measurement.
class Measurement {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "measurement";

  /// Index of the current measurement
  int64_t idx = 0;

  /// The measurement result as a serialized JSON.
  std::string json_str = "";
};

/// Event emitted once at the end of the nettest. This event is always emitted,
/// regardless of whether the nettest naturally reaches its end or is
/// interrupted. As such, you can rely on this event as a "once" suitable for
/// releasing all the extra resources you may have allocated as part of the
/// nettest lifecyle.
class StatusEnd {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.end";

  /// The number of KB downloaded during the test.
  double downloaded_kb = 0.0;

  /// The number of KB uploaded during the test.
  double uploaded_kb = 0.0;

  /// The error that occurred. If no error occurred, then this variable will
  /// hold an empty string.
  std::string failure = "";
};

/// Event emitted once, when we discover the geolocation of the user based on
/// their IP address.
class StatusGeoipLookup {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.geoip_lookup";

  /// The user IP address
  std::string probe_ip = "";

  /// The user ASN (Autonomous System Number)
  std::string probe_asn = "";

  /// The user country code (CC).
  std::string probe_cc = "";

  /// The descriptive name associated to the ASN
  std::string probe_network_name = "";
};

/// Emitted during the task lifecycle to indicate progress.
class StatusProgress {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.progress";

  /// Percentage of completion of the task.
  double percentage = 0.0;

  /// Optional message indicating what step is now complete.
  std::string message = "";
};

/// Emitted once to indicate that the tast has been submitted for running.
/// Unless you run multiple test at the same time (which is discouraged), this
/// event also implies that the test will be started immediately.
class StatusQueued {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.queued";
};

/// Emitted when we start a new measurement within a nettest. For nettests that
/// do not require input, there is just a single measurement within a nettest.
/// Otherwise, there is a measurement for each input provided to the nettest.
class StatusMeasurementStart {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.measurement_start";

  /// Index of the current measurement.
  int64_t idx = 0;

  /// Input of the current measurement. For nettests that do not take input,
  /// this will be the empty string.
  std::string input = "";
};

/// Emitted when the result of a measurement has been successfully submitted to
/// the configured collector.
class StatusMeasurementSubmission {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.measurement_submission";

  /// Index of the current measurement.
  int64_t idx = 0;
};

/// Emitted when a measurement is done. This is emitted regardless of whether
/// there were any failures during the measurement.
class StatusMeasurementDone {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.measurement_done";

  /// Index of the current measurement.
  int64_t idx = 0;
};

/// Emitted when we have notified the collector that we are done with running
/// measurements with a specific report ID.
class StatusReportClose {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.report_close";

  /// Unique identifier of the nettest with the collector.
  std::string report_id = "";
};

/// Emitted when we have notified the collector the intention to start
/// submitting measurements. As part of this API call, we receive back a "report
/// ID" to be used to submit subsequent measurements that we perform.
class StatusReportCreate {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.report_create";

  /// Unique identifier of the nettest with the collector.
  std::string report_id = "";
};

/// Emitted once when we discover the user DNS resolver IP.
class StatusResolverLookup {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.resolver_lookup";

  /// IP address of the user resolver.
  std::string ip_address = "";
};

/// Emitted once when the nettest has started running.
class StatusStarted {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.started";
};

/// Status update regarding the currently ongoing network performance
/// measurement. This event is, of course, only emitted by network tests that
/// measure the network performance.
class StatusUpdatePerformance {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.update_performance";

  /// The direction of the performance measurement. Either 'download', for
  /// download measurements, or 'upload' for upload measurements.
  std::string direction = "";

  /// Seconds elapsed since the performance measurement was started.
  double elapsed = 0.0;

  /// Number of parallel TCP streams being used.
  int64_t num_streams = 0;

  /// Speed measured in kbit/s.
  double speed_kbps = 0.0;
};

/// Status update regarding the currently ongoing website censorship
/// measurement.
class StatusUpdateWebsites {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "status.update.websites";

  /// URL that we are measuring.
  std::string url = "";

  /// Result of the measurement. Either "accessible" or "blocking".
  std::string status = "";
};

/// Emitted when a nettest is done and you attempt using the FFI API to extract
/// more tasks from its queue.
class TaskTerminated {
 public:
  /// The key that uniquely identifies an event. To disable an event, append
  /// this key to the settings::Settings::disabled_events array.
  static constexpr const char *event_key = "task_terminated";
};

}  // namespace events

/// Contains the settings classes. We have a specific setting class for
/// each supported network test. This inherits from generic settings
/// defined by a base class called settings::Settings.
namespace settings {

/// Generic settings of a network test.
class Settings {
 public:
  /// Optional annotations (i.e. key, value string pairs) that will be included
  /// into the JSON report sent to the OONI collector.
  std::map<std::string, std::string> annotations = {};

  /// List of events that will not be emitted.
  std::vector<std::string> disabled_events = {};

  /// List of URLs or domains required by the test.
  std::vector<std::string> inputs = {};

  /// List of files from which to read inputs.
  std::vector<std::string> input_filepaths = {};

  /// File where to write log messages.
  std::string log_filepath = "";

  /// Type of log messages you are interested into.
  std::string log_level = "ERR";

  /// File where to write the nettest results.
  std::string output_filepath = "";

  /// Base URL of the OONI bouncer. This base URL is used to construct the full
  /// URL required to contact the OONI bouncer and get test specific info like
  /// test helpers and test collectors.
  std::string bouncer_base_url = "https://bouncer.ooni.io";

  /// Base URL of the OONI collector. This base URL is used to construct the
  /// full URL required to contact manage the report submission with the
  /// collector. By default this option is not set because we use the bouncer to
  /// retrieve the collector base URL.
  std::string collector_base_url = "";

  /// DNS resolver IP address. By setting this option you will force MK to use
  /// that DNS resolver for resolving domain names to IP addresses. For this
  /// setting to work you should use a DNS engine different from the "system"
  /// engine. By default this option is not set, as we use the system engine as
  /// our default DNS engine.
  std::string dns_nameserver = "";

  /// What DNS engine to use. The "system" engine implies that `getaddrinfo()`
  /// is used. If you set this setting to "libevent" and you also configure the
  /// "dns/nameserver" option, MK will use libevent and the specified nameserver
  /// to resolve domain names.
  std::string dns_engine = "system";

  /// Path to the GeoIP ASN (Autonomous System Number) database file. By default
  /// this option is empty. If you do not change this option to contain the path
  /// to a suitable database file, MK will not be able to map the user's IP
  /// address to an ASN.
  std::string geoip_asn_path = "";

  /// Path to the GeoIP country database file. By default this option is empty.
  /// If you do not change it to contain the path to a suitable database file,
  /// MK will not be able to map the user's IP to a country code.
  std::string geoip_country_path = "";

  /// Whether to ignore bouncer errors. If this option is true, then MK will not
  /// stop after failing to contact the OONI bouncer. Without the information
  /// provided by the bouncer, OONI tests that require a test helper will
  /// certainly fail, while other tests will just fail to submit their results
  /// to a collector, unless you manually configure a collector base URL.
  bool ignore_bouncer_error = true;

  /// Whether to ignore errors opening the report with the OONI collector.
  bool ignore_open_report_error = true;

  /// Max run time for nettests taking input. When you are running a nettest
  /// taking input, the test will stop after the number of seconds specified by
  /// this option has passed (plus some extra time required to interrupt the
  /// testing engine). Setting this option to a negative value lets the test run
  /// as long as necessary to exhaust its input list.
  double max_runtime = -1.0;

  /// Path to the CA used to validate SSL certificates. This is not necessary
  /// where we use LibreSSL, because in such cases we include a CA bundle
  /// directly inside of the MK binary. This happens for Android, iOS, and
  /// Windows systems. If this option is not set and we're not using LibreSSL,
  /// then attempting to connect to any website using HTTPS will fail.
  std::string net_ca_bundle_path = "";

  /// Number of seconds after which network I/O operations (i.e. connect, recv,
  /// send) will timeout and return an error.
  double net_timeout = 10.0;

  /// Whether to avoid using a bouncer. Not using a bouncer means we will not
  /// discover the base URL of a suitable collector and of test helpers. OONI
  /// tests that require test helpers will fail if you disable the bouncer.
  /// Other tests will just not be able to submit results to a collector, unless
  /// you manually configure a collector base URL.
  bool no_bouncer = false;

  /// Whether to avoid using a collector. If true, it means that the test
  /// results are not submitted to a collector (by default the OONI collector)
  /// for archival or publishing purposes. All measurements submitted to the
  /// OONI collector are published within a few business days.
  bool no_collector = false;

  /// Whether to avoid the the user's ASN (Autonomous System Number) lookup.
  bool no_asn_lookup = false;

  /// Whether to avoid the user's country code lookup.
  bool no_cc_lookup = false;

  /// Whether to avoid looking up the user's IP. Not knowing it prevents us from
  /// looking up the ASN (Autonomous System Number) and the country code. Most
  /// importantly, this also prevents us from attempting to scrub the IP address
  /// from measurements results, which may be a concern for censorship tests.
  bool no_ip_lookup = false;

  /// Whether to avoid writing a report file to disk.
  bool no_file_report = false;

  /// Whether to avoid looking up the resolver IP address.
  bool no_resolver_lookup = false;

  /// The ASN (Autonomous System Number) in which we are. If you set this, we
  /// will of course skip the user's ASN lookup.
  std::string probe_asn = "";

  /// The country code in which we are. If you set this, we will of course skip
  /// the user's country code lookup.
  std::string probe_cc = "";

  /// The user's IP. If you set this, we will of course skip the user's IP
  /// lookup.
  std::string probe_ip = "";

  /// Whether to randomize the provided input.
  bool randomize_input = true;

  /// Whether to save the user's ASN (Autonomous System Number) in the report.
  bool save_real_probe_asn = true;

  /// Whether to save the user's country code in the report.
  bool save_real_probe_cc = true;

  /// Whether to save the user's IP in the report.
  bool save_real_probe_ip = false;

  /// Whether to save the user's resolver IP in the report.
  bool save_real_resolver_ip = true;

  /// Name of the application.
  std::string software_name = "measurement_kit";

  /// Version of the application. By default this is an empty string. If you do
  /// not set this variable, the current MK version will be used.
  std::string software_version = "";

  virtual ~Settings() noexcept;

  virtual void serialize_into(nlohmann::json *doc) const;
};

/// Full settings for OONI's captive portal test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-010-captive-portal.md.
class CaptivePortalSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~CaptivePortalSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for Neubot's DASH test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-021-dash.md.
class DashSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~DashSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's DNS injection test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-012-dns-injection.md.
class DnsInjectionSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = true;

  ~DnsInjectionSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's Facebook Messenger test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-019-facebook-messenger.md.
class FacebookMessengerSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~FacebookMessengerSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's HTTP header field manipulation test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-006-header-field-manipulation.md.
class HttpHeaderFieldManipulationSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~HttpHeaderFieldManipulationSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's HTTP invalid request line test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-007-http-invalid-request-line.md.
class HttpInvalidRequestLineSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~HttpInvalidRequestLineSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's meek fronted requests test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-014-meek-fronted-requests.md.
class MeekFrontedRequestsSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = true;

  ~MeekFrontedRequestsSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for the multi NDT network performance test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-022-ndt.md.
class MultiNdtSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~MultiNdtSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for the NDT network performance test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-022-ndt.md.
class NdtSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~NdtSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's TCP connect test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-008-tcp-connect.md.
class TcpConnectSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = true;

  ~TcpConnectSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's Telegram test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-020-telegram.md.
class TelegramSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~TelegramSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's Web Connectivity test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-017-web-connectivity.md.
class WebConnectivitySettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether this test requires input.
  static constexpr bool needs_input = true;

  ~WebConnectivitySettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

/// Full settings for OONI's WhatsApp test. See
/// https://github.com/ooni/spec/blob/master/test-specs/ts-018-whatsapp.md.
class WhatsappSettings : public Settings {
 public:
  using Settings::Settings;

  /// Whether to check all WhatsApp endpoints.
  bool all_endpoints = false;

  /// Whether this test requires input.
  static constexpr bool needs_input = false;

  ~WhatsappSettings() noexcept override;

  void serialize_into(nlohmann::json *doc) const override;
};

}  // namespace settings

/// Runs network tests and routes their events. Because most events are emitted
/// by all tests and just a couple of them are specific of specific tests, we
/// have not created a runner class for each test. Rather we have this one for
/// all the tests that we support in MK.
class Runner {
 public:
  /// Called when the FailureAsnLookup event occurs.
  virtual void on_failure_asn_lookup(const events::FailureAsnLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the FailureCcLookup event occurs.
  virtual void on_failure_cc_lookup(const events::FailureCcLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the FailureIpLookup event occurs.
  virtual void on_failure_ip_lookup(const events::FailureIpLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the FailureMeasurement event occurs.
  virtual void on_failure_measurement(const events::FailureMeasurement &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the FailureMeasurementSubmission event occurs.
  virtual void on_failure_measurement_submission(
      const events::FailureMeasurementSubmission &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the FailureReportCreate event occurs.
  virtual void on_failure_report_create(const events::FailureReportCreate &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the FailureReportClose event occurs.
  virtual void on_failure_report_close(const events::FailureReportClose &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the FailureResolverLookup event occurs.
  virtual void on_failure_resolver_lookup(
      const events::FailureResolverLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the FailureStartup event occurs.
  virtual void on_failure_startup(const events::FailureStartup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the Log event occurs.
  virtual void on_log(const events::Log &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the Measurement event occurs.
  virtual void on_measurement(const events::Measurement &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusEnd event occurs.
  virtual void on_status_end(const events::StatusEnd &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusGeoipLookup event occurs.
  virtual void on_status_geoip_lookup(const events::StatusGeoipLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusProgress event occurs.
  virtual void on_status_progress(const events::StatusProgress &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusQueued event occurs.
  virtual void on_status_queued(const events::StatusQueued &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusMeasurementStart event occurs.
  virtual void on_status_measurement_start(
      const events::StatusMeasurementStart &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusMeasurementSubmission event occurs.
  virtual void on_status_measurement_submission(
      const events::StatusMeasurementSubmission &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusMeasurementDone event occurs.
  virtual void on_status_measurement_done(
      const events::StatusMeasurementDone &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusReportClose event occurs.
  virtual void on_status_report_close(const events::StatusReportClose &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusReportCreate event occurs.
  virtual void on_status_report_create(const events::StatusReportCreate &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusResolverLookup event occurs.
  virtual void on_status_resolver_lookup(const events::StatusResolverLookup &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusStarted event occurs.
  virtual void on_status_started(const events::StatusStarted &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusUpdatePerformance event occurs.
  virtual void on_status_update_performance(
      const events::StatusUpdatePerformance &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the StatusUpdateWebsites event occurs.
  virtual void on_status_update_websites(const events::StatusUpdateWebsites &) {
    // TODO: override this callback if you're interested
  }

  /// Called when the TaskTerminated event occurs.
  virtual void on_task_terminated(const events::TaskTerminated &) {
    // TODO: override this callback if you're interested
  }

  /// Default constructor.
  Runner() noexcept {}

  /// Runs the nettest until completion. @throw std::exception when it is not
  /// possible to marshal/unmarshal data structures from/to JSON as well as
  /// if unexpected error conditions occurs. @remark in the event in which an
  /// exception is thrown, the stack will unwind, the currently running test
  /// will be interrupted and the thread in which it is running will be joined.
  void run(const settings::Settings &settings);

  virtual ~Runner() noexcept;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can exclude by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#ifndef MK_NETTEST_NO_INLINE_IMPL

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

namespace settings {

Settings::~Settings() noexcept {}

void Settings::serialize_into(nlohmann::json *doc) const {
  assert(doc != nullptr);
  (*doc)["annotations"] = annotations;
  (*doc)["disabled_events"] = disabled_events;
  (*doc)["inputs"] = inputs;
  (*doc)["input_filepaths"] = input_filepaths;
  (*doc)["log_filepath"] = log_filepath;
  (*doc)["log_level"] = log_level;
  (*doc)["output_filepath"] = output_filepath;
  {
    nlohmann::json so;
    so["bouncer_base_url"] = bouncer_base_url;
    so["collector_base_url"] = collector_base_url;
    so["dns/nameserver"] = dns_nameserver;
    so["dns/engine"] = dns_engine;
    so["geoip_asn_path"] = geoip_asn_path;
    so["geoip_country_path"] = geoip_country_path;
    so["ignore_bouncer_error"] = (int64_t)ignore_bouncer_error;
    so["ignore_open_report_error"] = (int64_t)ignore_open_report_error;
    so["max_runtime"] = max_runtime;
    so["net/ca_bundle_path"] = net_ca_bundle_path;
    so["net/timeout"] = net_timeout;
    so["no_bouncer"] = (int64_t)no_bouncer;
    so["no_collector"] = (int64_t)no_collector;
    so["no_asn_lookup"] = (int64_t)no_asn_lookup;
    so["no_cc_lookup"] = (int64_t)no_cc_lookup;
    so["no_ip_lookup"] = (int64_t)no_ip_lookup;
    so["no_file_report"] = (int64_t)no_file_report;
    so["no_resolver_lookup"] = (int64_t)no_resolver_lookup;
    so["probe_asn"] = probe_asn;
    so["probe_cc"] = probe_cc;
    so["probe_ip"] = probe_ip;
    so["randomize_input"] = (int64_t)randomize_input;
    so["save_real_probe_asn"] = (int64_t)save_real_probe_asn;
    so["save_real_probe_cc"] = (int64_t)save_real_probe_cc;
    so["save_real_probe_ip"] = (int64_t)save_real_probe_ip;
    so["save_real_resolver_ip"] = (int64_t)save_real_resolver_ip;
    so["software_name"] = software_name;
    so["software_version"] = software_version;
    (*doc)["options"] = so;
  }
}

CaptivePortalSettings::~CaptivePortalSettings() noexcept {}

void CaptivePortalSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "CaptivePortal";
}

DashSettings::~DashSettings() noexcept {}

void DashSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "Dash";
}

DnsInjectionSettings::~DnsInjectionSettings() noexcept {}

void DnsInjectionSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "DnsInjection";
}

FacebookMessengerSettings::~FacebookMessengerSettings() noexcept {}

void FacebookMessengerSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "FacebookMessenger";
}

HttpHeaderFieldManipulationSettings::
    ~HttpHeaderFieldManipulationSettings() noexcept {}

void HttpHeaderFieldManipulationSettings::serialize_into(
    nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "HttpHeaderFieldManipulation";
}

HttpInvalidRequestLineSettings::~HttpInvalidRequestLineSettings() noexcept {}

void HttpInvalidRequestLineSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "HttpInvalidRequestLine";
}

MeekFrontedRequestsSettings::~MeekFrontedRequestsSettings() noexcept {}

void MeekFrontedRequestsSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "MeekFrontedRequests";
}

MultiNdtSettings::~MultiNdtSettings() noexcept {}

void MultiNdtSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "MultiNdt";
}

NdtSettings::~NdtSettings() noexcept {}

void NdtSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "Ndt";
}

TcpConnectSettings::~TcpConnectSettings() noexcept {}

void TcpConnectSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "TcpConnect";
}

TelegramSettings::~TelegramSettings() noexcept {}

void TelegramSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "Telegram";
}

WebConnectivitySettings::~WebConnectivitySettings() noexcept {}

void WebConnectivitySettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "WebConnectivity";
}

WhatsappSettings::~WhatsappSettings() noexcept {}

void WhatsappSettings::serialize_into(nlohmann::json *doc) const {
  Settings::serialize_into(doc);
  (*doc)["name"] = "Whatsapp";
  (*doc)["options"]["all_endpoints"] = (int64_t)all_endpoints;
}

}  // namespace settings

Runner::~Runner() noexcept {}

void Runner::run(const settings::Settings &settings) {
  UniqueTask task;
  {
    nlohmann::json s;
    settings.serialize_into(&s);
    task.reset(mk_task_start(s.dump().c_str()));
    if (!task) {
      throw std::runtime_error("mk_task_start() failed");
    }
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
      ev = nlohmann::json::parse(str);
    }
    if (ev.at("key") == "failure.asn_lookup") {
      events::FailureAsnLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_asn_lookup(event);
      continue;
    }
    if (ev.at("key") == "failure.cc_lookup") {
      events::FailureCcLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_cc_lookup(event);
      continue;
    }
    if (ev.at("key") == "failure.ip_lookup") {
      events::FailureIpLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_ip_lookup(event);
      continue;
    }
    if (ev.at("key") == "failure.measurement") {
      events::FailureMeasurement event;
      event.failure = ev.at("value").at("failure");
      on_failure_measurement(event);
      continue;
    }
    if (ev.at("key") == "failure.measurement_submission") {
      events::FailureMeasurementSubmission event;
      event.failure = ev.at("value").at("failure");
      event.idx = ev.at("value").at("idx");
      event.json_str = ev.at("value").at("json_str");
      on_failure_measurement_submission(event);
      continue;
    }
    if (ev.at("key") == "failure.report_create") {
      events::FailureReportCreate event;
      event.failure = ev.at("value").at("failure");
      on_failure_report_create(event);
      continue;
    }
    if (ev.at("key") == "failure.report_close") {
      events::FailureReportClose event;
      event.failure = ev.at("value").at("failure");
      on_failure_report_close(event);
      continue;
    }
    if (ev.at("key") == "failure.resolver_lookup") {
      events::FailureResolverLookup event;
      event.failure = ev.at("value").at("failure");
      on_failure_resolver_lookup(event);
      continue;
    }
    if (ev.at("key") == "failure.startup") {
      events::FailureStartup event;
      event.failure = ev.at("value").at("failure");
      on_failure_startup(event);
      continue;
    }
    if (ev.at("key") == "log") {
      events::Log event;
      event.log_level = ev.at("value").at("log_level");
      event.message = ev.at("value").at("message");
      on_log(event);
      continue;
    }
    if (ev.at("key") == "measurement") {
      events::Measurement event;
      event.idx = ev.at("value").at("idx");
      event.json_str = ev.at("value").at("json_str");
      on_measurement(event);
      continue;
    }
    if (ev.at("key") == "status.end") {
      events::StatusEnd event;
      event.downloaded_kb = ev.at("value").at("downloaded_kb");
      event.uploaded_kb = ev.at("value").at("uploaded_kb");
      event.failure = ev.at("value").at("failure");
      on_status_end(event);
      continue;
    }
    if (ev.at("key") == "status.geoip_lookup") {
      events::StatusGeoipLookup event;
      event.probe_ip = ev.at("value").at("probe_ip");
      event.probe_asn = ev.at("value").at("probe_asn");
      event.probe_cc = ev.at("value").at("probe_cc");
      event.probe_network_name = ev.at("value").at("probe_network_name");
      on_status_geoip_lookup(event);
      continue;
    }
    if (ev.at("key") == "status.progress") {
      events::StatusProgress event;
      event.percentage = ev.at("value").at("percentage");
      event.message = ev.at("value").at("message");
      on_status_progress(event);
      continue;
    }
    if (ev.at("key") == "status.queued") {
      events::StatusQueued event;
      on_status_queued(event);
      continue;
    }
    if (ev.at("key") == "status.measurement_start") {
      events::StatusMeasurementStart event;
      event.idx = ev.at("value").at("idx");
      event.input = ev.at("value").at("input");
      on_status_measurement_start(event);
      continue;
    }
    if (ev.at("key") == "status.measurement_submission") {
      events::StatusMeasurementSubmission event;
      event.idx = ev.at("value").at("idx");
      on_status_measurement_submission(event);
      continue;
    }
    if (ev.at("key") == "status.measurement_done") {
      events::StatusMeasurementDone event;
      event.idx = ev.at("value").at("idx");
      on_status_measurement_done(event);
      continue;
    }
    if (ev.at("key") == "status.report_close") {
      events::StatusReportClose event;
      event.report_id = ev.at("value").at("report_id");
      on_status_report_close(event);
      continue;
    }
    if (ev.at("key") == "status.report_create") {
      events::StatusReportCreate event;
      event.report_id = ev.at("value").at("report_id");
      on_status_report_create(event);
      continue;
    }
    if (ev.at("key") == "status.resolver_lookup") {
      events::StatusResolverLookup event;
      event.ip_address = ev.at("value").at("ip_address");
      on_status_resolver_lookup(event);
      continue;
    }
    if (ev.at("key") == "status.started") {
      events::StatusStarted event;
      on_status_started(event);
      continue;
    }
    if (ev.at("key") == "status.update_performance") {
      events::StatusUpdatePerformance event;
      event.direction = ev.at("value").at("direction");
      event.elapsed = ev.at("value").at("elapsed");
      event.num_streams = ev.at("value").at("num_streams");
      event.speed_kbps = ev.at("value").at("speed_kbps");
      on_status_update_performance(event);
      continue;
    }
    if (ev.at("key") == "status.update.websites") {
      events::StatusUpdateWebsites event;
      event.url = ev.at("value").at("url");
      event.status = ev.at("value").at("status");
      on_status_update_websites(event);
      continue;
    }
    if (ev.at("key") == "task_terminated") {
      events::TaskTerminated event;
      on_task_terminated(event);
      continue;
    }
    std::clog << "unhandled event: " << ev.at("key");
  }
}
#endif  // MK_NETTEST_NO_INLINE_IMPL

}  // namespace nettest
}  // namespace mk
/// @}
#endif  // MEASUREMENT_KIT_NETTEST_NETTEST_HPP
