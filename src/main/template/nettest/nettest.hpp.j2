// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// @file measurement_kit/nettest/nettest.hpp
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.
///
/// The core idea behind this API is that a network test (nettest) requires
/// some settings and will generate some events while running. Such events
/// could be, e.g., a log line, a piece of result.
///
/// As a general rule, use documented features. Undocumented features are
/// much more likely to be replaced or changed without notice.
///
/// Usage is as follows:
///
/// 1) Instantiate a settings class for the network test that you want
/// to run. For example:
///
/// ```
/// #include <measurement_kit/nettest/nettest.hpp>
///
/// mk::nettest::settings::Whatsapp settings;
/// ```
///
/// Then, configure all options for which you do not like the default and
/// supply the required parameters (e.g. input list for tests requiring input).
///
/// ```
/// settings.all_endpoints = true;
/// settings.log_level = settings.log_level_debug;
/// ```
///
/// There is a common base class for all settings that contains the options
/// settable by more than one nettest. This design should allow you to easily
/// write sections of code that set options common to many tests.
///
/// 2) Write a derived class of Runner where you override the virtual methods
/// handling the events that you would like to process. There is a single
/// runner allowing to run different nettests, such that you can use the same
/// class for different nettests, if that makes sense for your use case.
///
/// ```
/// class MyRunner : public mk::nettest::Runner {
///  public:
///   using mk::nettest::Runner::Runner;
///
///   void on_log(const mk::nettest::event::Log &evt) override {
///     std::clog << "<" << evt.log_level << ">" << evt.message << std::endl;
///   }
/// };
/// ```
///
/// 3) Instantiate your runner and run the test with your settings. To do that,
/// chain the prepare_NETTEST_NAME() and then run() methods.
///
/// ```
/// MyRunner runner;
/// // ...
/// runner.run(runner.prepare_whatsapp(settings));
/// ```
///
/// Note that prepare_NETTEST_NAME() and run() are two separate methods so that
/// you can prepare a nettest in nettest specific code and use common code to
/// actually execute it. That is:
///
/// ```
/// // Alternative example where runner.run() occurs much later.
/// MyRunner runner;
/// // ...
/// std::string serialized_config = runner.prepare_whatsapp(settings);
/// // ...
/// runner.run(serialized_config);
/// ```
///
/// Exceptions derived from `std::exception` MAY be emitted in case of serious
/// internal error. As such, it can probably make sense to just ignore them. If
/// an exception is thrown, the running network test is automatically stopped
/// and the related thread is joined.
///
/// @addtogroup nettest Nettest API
/// @brief C++11 API for running nettests.
/// @{

#include <assert.h>
#include <stdint.h>

#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <vector>
#include <utility>

#include <measurement_kit/ffi.h>
#include <nlohmann/json.hpp>

/// Contains MK code.
namespace mk {

/// Contains the nettest API.
namespace nettest {

/// Contains the events classes. During its lifecycle, a network test emits
/// events in reaction to what happens. The Runner will call a specific
/// callback for any kind of event.
namespace event {

{% for event in events %}
/// {{ event.docs }}
class {{ event.key.to_pascal_case() }} {
 public:
  /// The key that uniquely identifies an event.
  static constexpr const char *key = "{{ event.key }}";

  {% for attribute in event.attributes %}
  /// {{ attribute.docs }}
  {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}
};
{% endfor %}

}  // namespace event

/// Contains the settings classes.
namespace settings {

/// Settings common to all network tests.
class Common {
 public:
  {% for log_level in log_levels %}
  /// {{ log_level.docs }}.
  static constexpr const char *log_level_{{ log_level.key.to_snake_case() }} = "{{ log_level.key.to_snake_case_upper() }}";
  {% endfor %}

  {% for attribute in settings if not attribute.low_level %}
  /// {{ attribute.docs }}
  {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}

  {% for attribute in options %}
  /// {{ attribute.docs }}
  {{ attribute.base_type.decl("cxx") }} {{ attribute.key.to_snake_case() }} = {{ attribute.base_type.default_value("cxx") }};
  {% endfor %}
};

{% for nettest in nettests %}
/// Full settings for {{ nettest.docs }}. See {{ nettest.reference_url }}.
class {{ nettest.key.to_pascal_case() }} : public Common {
 public:
  /// Whether this test requires input.
  static constexpr bool needs_input = {{ nettest.needs_input.default_value("cxx") }};

  {% if nettest.options is not none %}{% for option in nettest.options %}/// {{ option.docs }}
  {{ option.base_type.decl("cxx") }} {{ option.key.to_snake_case() }} = {{ option.base_type.default_value("cxx") }};{% endfor %}{% endif %}
};
{% endfor %}

}  // namespace settings

/// Runs network tests and routes their events.
class Runner {
 public:
  // Event handlers
  // --------------

  {% for event in events %}
  /// Called when the {{ event.key.to_pascal_case() }} event occurs. Override
  /// this method if you are interested to this event.
  virtual void on_{{ event.key.to_snake_case() }}(const event::{{ event.key.to_pascal_case() }} &);
  {% endfor %}

  // Runners
  // -------

  {% for nettest in nettests %}
  /// Prepare for running {{ nettest.key }} until completion. @return the
  /// string to be passed to run(), at your earliest convenience, to
  /// actually run the configured test. @throw std::exception when it is
  /// not possible to marshal/unmarshal data structures from/to JSON as
  /// well as if unexpected error conditions occurs. @remark in case
  /// of exception, the stack will unwind, the currently running test
  /// will be interrupted and we will wait for the completion of the
  /// background thread running the nettest.
  std::string prepare_{{ nettest.key.to_snake_case() }}(const settings::{{ nettest.key.to_pascal_case() }} &settings);
  {% endfor %}

  /// Run the nettest identified by @p s. @param s should be a string
  /// returned to you by one of the prepare_NETTEST_NAME() methods. @throw
  /// std::exception when it is not possible to marshal/unmarshal data
  /// structures from/to JSON as well on internal errors.
  void run(std::string s);

  // Misc
  // ----

  Runner() noexcept;

  virtual ~Runner() noexcept;

 private:
  std::string prepare_common(nlohmann::json &&doc, const settings::Common &common);
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can exclude by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#if !defined MK_NETTEST_NO_INLINE_IMPL && !defined SWIG

// Utility classes
// ---------------

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

// Empty event handlers
// --------------------

{% for event in events %}
void Runner::on_{{ event.key.to_snake_case() }}(const event::{{ event.key.to_pascal_case() }} &) {}
{% endfor %}

// Preparing nettests
// ------------------

{% for nettest in nettests %}
std::string Runner::prepare_{{ nettest.key.to_snake_case() }}(const settings::{{ nettest.key.to_pascal_case() }} &settings) {
  nlohmann::json doc;
  doc["name"] = "{{ nettest.key.to_pascal_case() }}";{% if nettest.options is not none %}{% for option in nettest.options %} doc["options"]["{{ option.key }}"] = {{ option.base_type.to_json_cast("cxx") }}settings.{{ option.key.to_snake_case() }};{% endfor %}{% endif %}
  return prepare_common(std::move(doc), settings);
}
{% endfor %}

std::string Runner::prepare_common(nlohmann::json &&doc, const settings::Common &cs) {
  {% for attribute in settings if not attribute.low_level %} doc["{{ attribute.key }}"] = {{ attribute.base_type.to_json_cast("cxx") }}cs.{{ attribute.key.to_snake_case() }}; {% endfor %}
  {
    auto &o = doc["options"];
    {% for attribute in options %} o["{{ attribute.key }}"] = {{ attribute.base_type.to_json_cast("cxx") }}cs.{{ attribute.key.to_snake_case() }}; {% endfor %}
  }
  return doc.dump();
}

void Runner::run(std::string str) {
  UniqueTask task;
#ifdef MK_NETTEST_TRACE
  std::clog << "NETTEST: settings: " << str << std::endl;
#endif
  task.reset(mk_task_start(str.c_str()));
  if (!task) {
    throw std::runtime_error("mk_task_start() failed");
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
#ifdef MK_NETTEST_TRACE
      std::clog << "NETTEST: event: " << str << std::endl;
#endif
      ev = nlohmann::json::parse(str);
    }
    {% for event in events %}if (ev.at("key") == event::{{ event.key.to_pascal_case() }}::key) {
      event::{{ event.key.to_pascal_case() }} event; {% for attribute in event.attributes %} event.{{ attribute.key.to_snake_case() }} = {{ attribute.base_type.from_json_cast("cxx") }} ev.at("value").at("{{ attribute.key }}"); {% endfor %}
      on_{{ event.key.to_snake_case() }}(event);
      continue;
    }{% endfor %}
    {
      std::stringstream reason;
      reason << "unhandled FFI event: " << ev.at("key");
      throw std::runtime_error(reason.str().c_str());
    }
  }
}

// Misc
// ----

Runner::Runner() noexcept {}

Runner::~Runner() noexcept {}

#endif  // !MK_NETTEST_NO_INLINE_IMPL && !SWIG
}  // namespace nettest
}  // namespace mk
/// @}
#endif  // MEASUREMENT_KIT_NETTEST_NETTEST_HPP
