// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by measurement-kit/ffi-tools; DO NOT EDIT!
 *
 * See https://github.com/measurement-kit/ffi-tools for more information.
 */

/// @file measurement_kit/nettest/nettest.hpp
///
/// This file contains Measurement Kit "nettest" API. This API allows you to
/// run network tests in a uniform way from a C++11 environment.
///
/// The core idea behind this API is that a network test (nettest) requires
/// some settings and will generate some events while running. Such events
/// could be, e.g., a log line, a piece of result.
///
/// As a general rule, use documented features. Undocumented features are
/// much more likely to be replaced or changed without notice.
///
/// Usage is as follows. Instantiate a settings class for the network test
/// that you want to execute. For example:
///
/// ```
/// #include <measurement_kit/nettest/nettest.hpp>
///
/// mk::nettest::settings::WebConnectivitySettings mySettings;
/// ```
///
/// Configure the settings you care about. Some settings are shared by all
/// network tests while others are nettest specific.
///
/// ```
/// mySettings.log_level = mk::nettest::log_levels::debug;
/// ```
///
/// Write a derived class of Runner where you override the virtual methods
/// handling the events that you would like to process.
///
/// ```
/// class MyRunner : public mk::nettest::Runner {
///  public:
///   using mk::nettest::Runner::Runner;
///
///   void on_log(const mk::nettest::events::Log &evt) override {
///     std::clog << "<" << evt.log_level << ">" << evt.message << std::endl;
///   }
/// };
/// ```
///
/// Instantiate your runner and run the test with your settings. Exceptions
/// derived from `std::exception` MAY be emitted in case of serious internal
/// error. You may want to be prepared for them.
///
/// ```
/// MyRunner runner;
/// try {
///   runner.run(mySettings);
/// } catch (const std::exception &exc) {
///   // TODO: handle
/// }
/// ```

// --->8 src/main/java/io/ooni/mk/nettest/LogLevels.java 8<---

package io.ooni.mk.nettest;

public class LogLevels {
  {% for log_level in log_levels %}
  public static final String {{log_level.key.to_camel_case() }} = "{{ log_level.key.to_snake_case_upper() }}";
  {% endfor %}
}

{% for event in events %}
// --->8 src/main/java/io/ooni/mk/nettest/events/{{ event.key.to_pascal_case() }}.java 8<---

package io.ooni.mk.nettest;

public class {{ event.key.to_pascal_case() }} {
  public static final String key = "{{ event.key }}";

  {% for attribute in event.attributes %}
  public {{ attribute.base_type.decl("java") }} {{ attribute.key.to_camel_case() }} = {{ attribute.base_type.default_value("java") }};
  {% endfor %}
}
{% endfor %}

// --->8 src/main/java/io/ooni/mk/nettest/settings/Settings.java 8<---

package io.ooni.mk.nettest;

public class Settings {
  {% for attribute in settings if not attribute.low_level %}
  public {{ attribute.base_type.decl("java") }} {{ attribute.key.to_camel_case() }} = {{ attribute.base_type.default_value("java") }};
  {% endfor %}{% for attribute in options %}
  public {{ attribute.base_type.decl("java") }} {{ attribute.key.to_camel_case() }} = {{ attribute.base_type.default_value("java") }};
  {% endfor %}

  void fillSwigSettings(io.ooni.mk.nettest.swig.Settings settings) {
  }
}

// --->8 src/main/java/io/ooni/mk/nettest/settings/{{ nettest.key.to_pascal_case() }}Settings.java 8<---

package io.ooni.mk.nettest;

public class {{ nettest.key.to_pascal_case() }}Settings extends Settings {
  public static final boolean needsInput = {{ nettest.needs_input.default_value("java") }};
  {% if nettest.options is not none %}{% for option in nettest.options %}
  public {{ option.base_type.decl("java") }} {{ option.key.to_camel_case() }} = {{ option.base_type.default_value("java") }};
  {% endfor %}{% endif %}
}
{% endfor %}

// --->8 src/main/java/io/ooni/mk/nettest/Runner.java 8<---

package io.ooni.mk.nettest;

public class Runner {
  {% for event in events %}
  void on{{ event.key.to_pascal_case() }}(io.ooni.mk.nettest.events.{{ event.key.to_pascal_case() }} event) {
    // TODO: override this callback if you're interested
  }
  {% endfor %}

  void run(io.ooni.mk.nettest.settings.Settings settings) {
  }
}

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can exclude by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#ifndef MK_NETTEST_NO_INLINE_IMPL

class TaskDeleter {
 public:
  void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

class EventDeleter {
 public:
  void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

namespace settings {

Settings::~Settings() noexcept {}

void Settings::serialize_into(nlohmann::json *doc) const {
  assert(doc != nullptr);
  {% for attribute in settings if not attribute.low_level %} (*doc)["{{ attribute.key }}"] = {{ attribute.base_type.to_json_cast("cxx") }} {{ attribute.key.to_snake_case() }}; {% endfor %}
  {
    nlohmann::json so;
    {% for attribute in options %} so["{{ attribute.key }}"] = {{ attribute.base_type.to_json_cast("cxx") }} {{ attribute.key.to_snake_case() }}; {% endfor %}
    (*doc)["options"] = so;
  }
}

{% for nettest in nettests %}
  {{ nettest.key.to_pascal_case() }}Settings::~{{ nettest.key.to_pascal_case() }}Settings() noexcept {}

  void {{ nettest.key.to_pascal_case() }}Settings::serialize_into(nlohmann::json *doc) const {
    Settings::serialize_into(doc);
    (*doc)["name"] = "{{ nettest.key.to_pascal_case() }}";
    {% if nettest.options is not none %}{% for option in nettest.options %} (*doc)["options"]["{{ option.key }}"] = {{ option.base_type.to_json_cast("cxx") }} {{ option.key.to_snake_case() }}; {% endfor %} {% endif %}
  }
{% endfor %}

}  // namespace settings

Runner::~Runner() noexcept {}

void Runner::run(const settings::Settings &settings) {
  UniqueTask task;
  {
    nlohmann::json doc;
    settings.serialize_into(&doc);
    auto str = doc.dump();
#ifdef MK_NETTEST_TRACE
    std::clog << "NETTEST: settings: " << str << std::endl;
#endif
    task.reset(mk_task_start(str.c_str()));
    if (!task) {
      throw std::runtime_error("mk_task_start() failed");
    }
  }
  while (!mk_task_is_done(task.get())) {
    nlohmann::json ev;
    {
      UniqueEvent event{mk_task_wait_for_next_event(task.get())};
      if (!event) {
        throw std::runtime_error("mk_task_wait_for_next_event() failed");
      }
      auto str = mk_event_serialize(event.get());
      if (!str) {
        throw std::runtime_error("mk_event_serialize() failed");
      }
#ifdef MK_NETTEST_TRACE
      std::clog << "NETTEST: event: " << str << std::endl;
#endif
      ev = nlohmann::json::parse(str);
    }
    {% for event in events %}if (ev.at("key") == "{{ event.key }}") {
      events::{{ event.key.to_pascal_case() }} event; {% for attribute in event.attributes %} event.{{ attribute.key.to_snake_case() }} = {{ attribute.base_type.from_json_cast("cxx") }} ev.at("value").at("{{ attribute.key }}"); {% endfor %}
      on_{{ event.key.to_snake_case() }}(event);
      continue;
    }{% endfor %}
    {
      std::stringstream reason;
      reason << "unhandled FFI event: " << ev.at("key");
      throw std::runtime_error(reason.str().c_str());
    }
  }
}
#endif  // MK_NETTEST_NO_INLINE_IMPL

}  // namespace nettest
}  // namespace mk
#endif  // MEASUREMENT_KIT_NETTEST_NETTEST_HPP
